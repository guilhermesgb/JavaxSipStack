//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: ./src/android/gov/nist/javax/sip/stack/IOHandler.java
//

#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "android/gov/nist/core/net/NetworkLayer.h"
#include "android/gov/nist/javax/sip/SipStackImpl.h"
#include "android/gov/nist/javax/sip/TlsSecurityPolicy.h"
#include "android/gov/nist/javax/sip/stack/HandshakeCompletedListenerImpl.h"
#include "android/gov/nist/javax/sip/stack/IOHandler.h"
#include "android/gov/nist/javax/sip/stack/MessageChannel.h"
#include "android/gov/nist/javax/sip/stack/SIPClientTransaction.h"
#include "android/gov/nist/javax/sip/stack/SIPTransactionStack.h"
#include "android/gov/nist/javax/sip/stack/TLSMessageChannel.h"
#include "java/io/IOException.h"
#include "java/io/OutputStream.h"
#include "java/lang/Exception.h"
#include "java/lang/InterruptedException.h"
#include "java/lang/SecurityException.h"
#include "java/net/DatagramPacket.h"
#include "java/net/DatagramSocket.h"
#include "java/net/InetAddress.h"
#include "java/net/Socket.h"
#include "java/net/SocketAddress.h"
#include "java/net/SocketException.h"
#include "java/util/Enumeration.h"
#include "java/util/concurrent/ConcurrentHashMap.h"
#include "java/util/concurrent/Semaphore.h"
#include "java/util/concurrent/TimeUnit.h"
#include "javax/net/ssl/SSLHandshakeException.h"
#include "javax/net/ssl/SSLSocket.h"
#include "org/slf4j/Logger.h"
#include "org/slf4j/LoggerFactory.h"

@interface AndroidGovNistJavaxSipStackIOHandler () {
 @public
  AndroidGovNistJavaxSipSipStackImpl *sipStack_;
  JavaUtilConcurrentConcurrentHashMap *socketTable_;
  JavaUtilConcurrentConcurrentHashMap *socketCreationMap_;
}

- (void)writeChunksWithJavaIoOutputStream:(JavaIoOutputStream *)outputStream
                            withByteArray:(IOSByteArray *)bytes
                                  withInt:(jint)length;

- (void)leaveIOCriticalSectionWithNSString:(NSString *)key;

- (void)enterIOCriticalSectionWithNSString:(NSString *)key;

@end

J2OBJC_FIELD_SETTER(AndroidGovNistJavaxSipStackIOHandler, sipStack_, AndroidGovNistJavaxSipSipStackImpl *)
J2OBJC_FIELD_SETTER(AndroidGovNistJavaxSipStackIOHandler, socketTable_, JavaUtilConcurrentConcurrentHashMap *)
J2OBJC_FIELD_SETTER(AndroidGovNistJavaxSipStackIOHandler, socketCreationMap_, JavaUtilConcurrentConcurrentHashMap *)

inline id<OrgSlf4jLogger> AndroidGovNistJavaxSipStackIOHandler_get_logger();
inline id<OrgSlf4jLogger> AndroidGovNistJavaxSipStackIOHandler_set_logger(id<OrgSlf4jLogger> value);
static id<OrgSlf4jLogger> AndroidGovNistJavaxSipStackIOHandler_logger;
J2OBJC_STATIC_FIELD_OBJ(AndroidGovNistJavaxSipStackIOHandler, logger, id<OrgSlf4jLogger>)

inline NSString *AndroidGovNistJavaxSipStackIOHandler_get_TCP();
static NSString *AndroidGovNistJavaxSipStackIOHandler_TCP = @"tcp";
J2OBJC_STATIC_FIELD_OBJ_FINAL(AndroidGovNistJavaxSipStackIOHandler, TCP, NSString *)

inline NSString *AndroidGovNistJavaxSipStackIOHandler_get_TLS();
static NSString *AndroidGovNistJavaxSipStackIOHandler_TLS = @"tls";
J2OBJC_STATIC_FIELD_OBJ_FINAL(AndroidGovNistJavaxSipStackIOHandler, TLS, NSString *)

__attribute__((unused)) static void AndroidGovNistJavaxSipStackIOHandler_writeChunksWithJavaIoOutputStream_withByteArray_withInt_(AndroidGovNistJavaxSipStackIOHandler *self, JavaIoOutputStream *outputStream, IOSByteArray *bytes, jint length);

__attribute__((unused)) static void AndroidGovNistJavaxSipStackIOHandler_leaveIOCriticalSectionWithNSString_(AndroidGovNistJavaxSipStackIOHandler *self, NSString *key);

__attribute__((unused)) static void AndroidGovNistJavaxSipStackIOHandler_enterIOCriticalSectionWithNSString_(AndroidGovNistJavaxSipStackIOHandler *self, NSString *key);

J2OBJC_INITIALIZED_DEFN(AndroidGovNistJavaxSipStackIOHandler)

@implementation AndroidGovNistJavaxSipStackIOHandler

+ (NSString *)makeKeyWithJavaNetInetAddress:(JavaNetInetAddress *)addr
                                    withInt:(jint)port {
  return AndroidGovNistJavaxSipStackIOHandler_makeKeyWithJavaNetInetAddress_withInt_(addr, port);
}

+ (NSString *)makeKeyWithNSString:(NSString *)addr
                          withInt:(jint)port {
  return AndroidGovNistJavaxSipStackIOHandler_makeKeyWithNSString_withInt_(addr, port);
}

- (instancetype)initWithAndroidGovNistJavaxSipStackSIPTransactionStack:(AndroidGovNistJavaxSipStackSIPTransactionStack *)sipStack {
  AndroidGovNistJavaxSipStackIOHandler_initWithAndroidGovNistJavaxSipStackSIPTransactionStack_(self, sipStack);
  return self;
}

- (void)putSocketWithNSString:(NSString *)key
            withJavaNetSocket:(JavaNetSocket *)sock {
  [((id<OrgSlf4jLogger>) nil_chk(AndroidGovNistJavaxSipStackIOHandler_logger)) debugWithNSString:JreStrcat("$$", @"adding socket for key ", key)];
  [((JavaUtilConcurrentConcurrentHashMap *) nil_chk(socketTable_)) putWithId:key withId:sock];
}

- (JavaNetSocket *)getSocketWithNSString:(NSString *)key {
  return [((JavaUtilConcurrentConcurrentHashMap *) nil_chk(socketTable_)) getWithId:key];
}

- (void)removeSocketWithNSString:(NSString *)key {
  [((JavaUtilConcurrentConcurrentHashMap *) nil_chk(socketTable_)) removeWithId:key];
  JavaUtilConcurrentSemaphore *s = [((JavaUtilConcurrentConcurrentHashMap *) nil_chk(socketCreationMap_)) removeWithId:key];
  if (s != nil) {
    [s release__];
  }
  [((id<OrgSlf4jLogger>) nil_chk(AndroidGovNistJavaxSipStackIOHandler_logger)) debugWithNSString:JreStrcat("$$", @"removed Socket and Semaphore for key ", key)];
}

- (void)writeChunksWithJavaIoOutputStream:(JavaIoOutputStream *)outputStream
                            withByteArray:(IOSByteArray *)bytes
                                  withInt:(jint)length {
  AndroidGovNistJavaxSipStackIOHandler_writeChunksWithJavaIoOutputStream_withByteArray_withInt_(self, outputStream, bytes, length);
}

- (JavaNetSocketAddress *)getLocalAddressForTcpDstWithJavaNetInetAddress:(JavaNetInetAddress *)dst
                                                                 withInt:(jint)dstPort
                                                  withJavaNetInetAddress:(JavaNetInetAddress *)localAddress
                                                                 withInt:(jint)localPort {
  NSString *key = AndroidGovNistJavaxSipStackIOHandler_makeKeyWithJavaNetInetAddress_withInt_(dst, dstPort);
  JavaNetSocket *clientSock = [self getSocketWithNSString:key];
  if (clientSock == nil) {
    clientSock = [((id<AndroidGovNistCoreNetNetworkLayer>) nil_chk([((AndroidGovNistJavaxSipSipStackImpl *) nil_chk(sipStack_)) getNetworkLayer])) createSocketWithJavaNetInetAddress:dst withInt:dstPort withJavaNetInetAddress:localAddress withInt:localPort];
    [self putSocketWithNSString:key withJavaNetSocket:clientSock];
  }
  return [((JavaNetSocket *) nil_chk(clientSock)) getLocalSocketAddress];
}

- (JavaNetSocketAddress *)getLocalAddressForTlsDstWithJavaNetInetAddress:(JavaNetInetAddress *)dst
                                                                 withInt:(jint)dstPort
                                                  withJavaNetInetAddress:(JavaNetInetAddress *)localAddress
                        withAndroidGovNistJavaxSipStackTLSMessageChannel:(AndroidGovNistJavaxSipStackTLSMessageChannel *)channel {
  NSString *key = AndroidGovNistJavaxSipStackIOHandler_makeKeyWithJavaNetInetAddress_withInt_(dst, dstPort);
  JavaNetSocket *clientSock = [self getSocketWithNSString:key];
  if (clientSock == nil) {
    clientSock = [((id<AndroidGovNistCoreNetNetworkLayer>) nil_chk([((AndroidGovNistJavaxSipSipStackImpl *) nil_chk(sipStack_)) getNetworkLayer])) createSSLSocketWithJavaNetInetAddress:dst withInt:dstPort withJavaNetInetAddress:localAddress];
    JavaxNetSslSSLSocket *sslsock = (JavaxNetSslSSLSocket *) cast_chk(clientSock, [JavaxNetSslSSLSocket class]);
    [((id<OrgSlf4jLogger>) nil_chk(AndroidGovNistJavaxSipStackIOHandler_logger)) debugWithNSString:JreStrcat("$@", @"inaddr = ", dst)];
    [((id<OrgSlf4jLogger>) nil_chk(AndroidGovNistJavaxSipStackIOHandler_logger)) debugWithNSString:JreStrcat("$I", @"port = ", dstPort)];
    AndroidGovNistJavaxSipStackHandshakeCompletedListenerImpl *listner = create_AndroidGovNistJavaxSipStackHandshakeCompletedListenerImpl_initWithAndroidGovNistJavaxSipStackTLSMessageChannel_withJavaNetSocket_(channel, sslsock);
    [((AndroidGovNistJavaxSipStackTLSMessageChannel *) nil_chk(channel)) setHandshakeCompletedListenerWithJavaxNetSslHandshakeCompletedListener:listner];
    [((JavaxNetSslSSLSocket *) nil_chk(sslsock)) addHandshakeCompletedListenerWithJavaxNetSslHandshakeCompletedListener:listner];
    [sslsock setEnabledProtocolsWithNSStringArray:[((AndroidGovNistJavaxSipSipStackImpl *) nil_chk(sipStack_)) getEnabledProtocols]];
    [sslsock setEnabledCipherSuitesWithNSStringArray:[((AndroidGovNistJavaxSipSipStackImpl *) nil_chk(sipStack_)) getEnabledCipherSuites]];
    [listner startHandshakeWatchdog];
    [sslsock startHandshake];
    [channel setHandshakeCompletedWithBoolean:true];
    [((id<OrgSlf4jLogger>) nil_chk(AndroidGovNistJavaxSipStackIOHandler_logger)) debugWithNSString:@"Handshake passed"];
    @try {
      [((id<AndroidGovNistJavaxSipTlsSecurityPolicy>) nil_chk([((AndroidGovNistJavaxSipSipStackImpl *) nil_chk(sipStack_)) getTlsSecurityPolicy])) enforceTlsPolicyWithAndroidGovNistJavaxSipClientTransactionExt:[channel getEncapsulatedClientTransaction]];
    }
    @catch (JavaLangSecurityException *ex) {
      @throw create_JavaIoIOException_initWithNSString_([((JavaLangSecurityException *) nil_chk(ex)) getMessage]);
    }
    [((id<OrgSlf4jLogger>) nil_chk(AndroidGovNistJavaxSipStackIOHandler_logger)) debugWithNSString:@"TLS Security policy passed"];
    [self putSocketWithNSString:key withJavaNetSocket:clientSock];
  }
  return [((JavaNetSocket *) nil_chk(clientSock)) getLocalSocketAddress];
}

- (JavaNetSocket *)sendBytesWithJavaNetInetAddress:(JavaNetInetAddress *)senderAddress
                            withJavaNetInetAddress:(JavaNetInetAddress *)receiverAddress
                                           withInt:(jint)contactPort
                                      withNSString:(NSString *)transport
                                     withByteArray:(IOSByteArray *)bytes
                                       withBoolean:(jboolean)isClient
     withAndroidGovNistJavaxSipStackMessageChannel:(AndroidGovNistJavaxSipStackMessageChannel *)messageChannel {
  jint retry_count = 0;
  jint max_retry = isClient ? 2 : 1;
  jint length = ((IOSByteArray *) nil_chk(bytes))->size_;
  [((id<OrgSlf4jLogger>) nil_chk(AndroidGovNistJavaxSipStackIOHandler_logger)) debugWithNSString:JreStrcat("$$$$$$$I$I$Z", @"sendBytes ", transport, @" local inAddr ", [((JavaNetInetAddress *) nil_chk(senderAddress)) getHostAddress], @" remote inAddr ", [((JavaNetInetAddress *) nil_chk(receiverAddress)) getHostAddress], @" port = ", contactPort, @" length = ", length, @" isClient ", isClient)];
  if ([((NSString *) nil_chk(transport)) java_compareToIgnoreCase:AndroidGovNistJavaxSipStackIOHandler_TCP] == 0) {
    NSString *key = AndroidGovNistJavaxSipStackIOHandler_makeKeyWithJavaNetInetAddress_withInt_(receiverAddress, contactPort);
    JavaNetSocket *clientSock = nil;
    AndroidGovNistJavaxSipStackIOHandler_enterIOCriticalSectionWithNSString_(self, key);
    @try {
      clientSock = [self getSocketWithNSString:key];
      while (retry_count < max_retry) {
        if (clientSock == nil) {
          [((id<OrgSlf4jLogger>) nil_chk(AndroidGovNistJavaxSipStackIOHandler_logger)) debugWithNSString:JreStrcat("$@", @"inaddr = ", receiverAddress)];
          [((id<OrgSlf4jLogger>) nil_chk(AndroidGovNistJavaxSipStackIOHandler_logger)) debugWithNSString:JreStrcat("$I", @"port = ", contactPort)];
          @try {
            clientSock = [((id<AndroidGovNistCoreNetNetworkLayer>) nil_chk([((AndroidGovNistJavaxSipSipStackImpl *) nil_chk(sipStack_)) getNetworkLayer])) createSocketWithJavaNetInetAddress:receiverAddress withInt:contactPort withJavaNetInetAddress:senderAddress];
          }
          @catch (JavaNetSocketException *e) {
            [((id<OrgSlf4jLogger>) nil_chk(AndroidGovNistJavaxSipStackIOHandler_logger)) errorWithNSString:JreStrcat("$@CIC@$$", @"Problem connecting ", receiverAddress, ' ', contactPort, ' ', senderAddress, @" for message ", [NSString java_stringWithBytes:bytes charsetName:@"UTF-8"])];
            [self removeSocketWithNSString:key];
            @throw create_JavaNetSocketException_initWithNSString_(JreStrcat("@C$C@$@CIC@$$", [((JavaNetSocketException *) nil_chk(e)) java_getClass], ' ', [e getMessage], ' ', [e getCause], @" Problem connecting ", receiverAddress, ' ', contactPort, ' ', senderAddress, @" for message ", [NSString java_stringWithBytes:bytes charsetName:@"UTF-8"]));
          }
          [((id<OrgSlf4jLogger>) nil_chk(AndroidGovNistJavaxSipStackIOHandler_logger)) debugWithNSString:JreStrcat("$$", @"local inaddr = ", [((JavaNetInetAddress *) nil_chk([((JavaNetSocket *) nil_chk(clientSock)) getLocalAddress])) getHostAddress])];
          JavaIoOutputStream *outputStream = [clientSock getOutputStream];
          AndroidGovNistJavaxSipStackIOHandler_writeChunksWithJavaIoOutputStream_withByteArray_withInt_(self, outputStream, bytes, length);
          [self putSocketWithNSString:key withJavaNetSocket:clientSock];
          break;
        }
        else {
          @try {
            JavaIoOutputStream *outputStream = [clientSock getOutputStream];
            AndroidGovNistJavaxSipStackIOHandler_writeChunksWithJavaIoOutputStream_withByteArray_withInt_(self, outputStream, bytes, length);
            break;
          }
          @catch (JavaIoIOException *ex) {
            [((id<OrgSlf4jLogger>) nil_chk(AndroidGovNistJavaxSipStackIOHandler_logger)) warnWithNSString:JreStrcat("$I", @"IOException occured retryCount ", retry_count)];
            @try {
              [clientSock close];
            }
            @catch (JavaLangException *e) {
            }
            clientSock = nil;
            retry_count++;
            if (!isClient) {
              [self removeSocketWithNSString:key];
              @throw ex;
            }
            if (retry_count >= max_retry) {
              [self removeSocketWithNSString:key];
            }
            else {
              [((JavaUtilConcurrentConcurrentHashMap *) nil_chk(socketTable_)) removeWithId:key];
            }
          }
        }
      }
    }
    @catch (JavaIoIOException *ex) {
      [((id<OrgSlf4jLogger>) nil_chk(AndroidGovNistJavaxSipStackIOHandler_logger)) errorWithNSString:JreStrcat("$$$$$I$$$I$I$Z", @"Problem sending: sendBytes ", transport, @" inAddr ", [receiverAddress getHostAddress], @" port = ", contactPort, @" remoteHost ", [((AndroidGovNistJavaxSipStackMessageChannel *) nil_chk(messageChannel)) getPeerAddress], @" remotePort ", [messageChannel getPeerPort], @" peerPacketPort ", [messageChannel getPeerPacketSourcePort], @" isClient ", isClient)];
      [self removeSocketWithNSString:key];
    }
    @finally {
      AndroidGovNistJavaxSipStackIOHandler_leaveIOCriticalSectionWithNSString_(self, key);
    }
    if (clientSock == nil) {
      [((id<OrgSlf4jLogger>) nil_chk(AndroidGovNistJavaxSipStackIOHandler_logger)) errorWithNSString:[((JavaUtilConcurrentConcurrentHashMap *) nil_chk(self->socketTable_)) description]];
      [((id<OrgSlf4jLogger>) nil_chk(AndroidGovNistJavaxSipStackIOHandler_logger)) errorWithNSString:JreStrcat("$@CI", @"Could not connect to ", receiverAddress, ':', contactPort)];
      @throw create_JavaIoIOException_initWithNSString_(JreStrcat("$@CI", @"Could not connect to ", receiverAddress, ':', contactPort));
    }
    else {
      return clientSock;
    }
  }
  else if ([transport java_compareToIgnoreCase:AndroidGovNistJavaxSipStackIOHandler_TLS] == 0) {
    NSString *key = AndroidGovNistJavaxSipStackIOHandler_makeKeyWithJavaNetInetAddress_withInt_(receiverAddress, contactPort);
    JavaNetSocket *clientSock = nil;
    AndroidGovNistJavaxSipStackIOHandler_enterIOCriticalSectionWithNSString_(self, key);
    @try {
      clientSock = [self getSocketWithNSString:key];
      while (retry_count < max_retry) {
        if (clientSock == nil) {
          clientSock = [((id<AndroidGovNistCoreNetNetworkLayer>) nil_chk([((AndroidGovNistJavaxSipSipStackImpl *) nil_chk(sipStack_)) getNetworkLayer])) createSSLSocketWithJavaNetInetAddress:receiverAddress withInt:contactPort withJavaNetInetAddress:senderAddress];
          JavaxNetSslSSLSocket *sslsock = (JavaxNetSslSSLSocket *) cast_chk(clientSock, [JavaxNetSslSSLSocket class]);
          [((id<OrgSlf4jLogger>) nil_chk(AndroidGovNistJavaxSipStackIOHandler_logger)) debugWithNSString:JreStrcat("$@", @"inaddr = ", receiverAddress)];
          [((id<OrgSlf4jLogger>) nil_chk(AndroidGovNistJavaxSipStackIOHandler_logger)) debugWithNSString:JreStrcat("$I", @"port = ", contactPort)];
          AndroidGovNistJavaxSipStackHandshakeCompletedListenerImpl *listner = create_AndroidGovNistJavaxSipStackHandshakeCompletedListenerImpl_initWithAndroidGovNistJavaxSipStackTLSMessageChannel_withJavaNetSocket_((AndroidGovNistJavaxSipStackTLSMessageChannel *) cast_chk(messageChannel, [AndroidGovNistJavaxSipStackTLSMessageChannel class]), clientSock);
          [((AndroidGovNistJavaxSipStackTLSMessageChannel *) nil_chk(((AndroidGovNistJavaxSipStackTLSMessageChannel *) cast_chk(messageChannel, [AndroidGovNistJavaxSipStackTLSMessageChannel class])))) setHandshakeCompletedListenerWithJavaxNetSslHandshakeCompletedListener:listner];
          [((JavaxNetSslSSLSocket *) nil_chk(sslsock)) addHandshakeCompletedListenerWithJavaxNetSslHandshakeCompletedListener:listner];
          [sslsock setEnabledProtocolsWithNSStringArray:[((AndroidGovNistJavaxSipSipStackImpl *) nil_chk(sipStack_)) getEnabledProtocols]];
          [listner startHandshakeWatchdog];
          [sslsock startHandshake];
          [((AndroidGovNistJavaxSipStackTLSMessageChannel *) nil_chk(((AndroidGovNistJavaxSipStackTLSMessageChannel *) cast_chk(messageChannel, [AndroidGovNistJavaxSipStackTLSMessageChannel class])))) setHandshakeCompletedWithBoolean:true];
          [((id<OrgSlf4jLogger>) nil_chk(AndroidGovNistJavaxSipStackIOHandler_logger)) debugWithNSString:@"Handshake passed"];
          @try {
            [((id<AndroidGovNistJavaxSipTlsSecurityPolicy>) nil_chk([((AndroidGovNistJavaxSipSipStackImpl *) nil_chk(sipStack_)) getTlsSecurityPolicy])) enforceTlsPolicyWithAndroidGovNistJavaxSipClientTransactionExt:[((AndroidGovNistJavaxSipStackMessageChannel *) nil_chk(messageChannel)) getEncapsulatedClientTransaction]];
          }
          @catch (JavaLangSecurityException *ex) {
            @throw create_JavaIoIOException_initWithNSString_([((JavaLangSecurityException *) nil_chk(ex)) getMessage]);
          }
          [((id<OrgSlf4jLogger>) nil_chk(AndroidGovNistJavaxSipStackIOHandler_logger)) debugWithNSString:@"TLS Security policy passed"];
          JavaIoOutputStream *outputStream = [((JavaNetSocket *) nil_chk(clientSock)) getOutputStream];
          AndroidGovNistJavaxSipStackIOHandler_writeChunksWithJavaIoOutputStream_withByteArray_withInt_(self, outputStream, bytes, length);
          [self putSocketWithNSString:key withJavaNetSocket:clientSock];
          break;
        }
        else {
          @try {
            JavaIoOutputStream *outputStream = [clientSock getOutputStream];
            AndroidGovNistJavaxSipStackIOHandler_writeChunksWithJavaIoOutputStream_withByteArray_withInt_(self, outputStream, bytes, length);
            break;
          }
          @catch (JavaIoIOException *ex) {
            [((id<OrgSlf4jLogger>) nil_chk(AndroidGovNistJavaxSipStackIOHandler_logger)) errorWithNSString:@"IOException" withNSException:ex];
            [self removeSocketWithNSString:key];
            @try {
              [((id<OrgSlf4jLogger>) nil_chk(AndroidGovNistJavaxSipStackIOHandler_logger)) debugWithNSString:@"Closing socket"];
              [clientSock close];
            }
            @catch (JavaLangException *e) {
            }
            clientSock = nil;
            retry_count++;
          }
        }
      }
    }
    @catch (JavaxNetSslSSLHandshakeException *ex) {
      [self removeSocketWithNSString:key];
      @throw ex;
    }
    @catch (JavaIoIOException *ex) {
      [self removeSocketWithNSString:key];
    }
    @finally {
      AndroidGovNistJavaxSipStackIOHandler_leaveIOCriticalSectionWithNSString_(self, key);
    }
    if (clientSock == nil) {
      @throw create_JavaIoIOException_initWithNSString_(JreStrcat("$@CI", @"Could not connect to ", receiverAddress, ':', contactPort));
    }
    else return clientSock;
  }
  else {
    JavaNetDatagramSocket *datagramSock = [((id<AndroidGovNistCoreNetNetworkLayer>) nil_chk([((AndroidGovNistJavaxSipSipStackImpl *) nil_chk(sipStack_)) getNetworkLayer])) createDatagramSocket];
    [((JavaNetDatagramSocket *) nil_chk(datagramSock)) connectWithJavaNetInetAddress:receiverAddress withInt:contactPort];
    JavaNetDatagramPacket *dgPacket = create_JavaNetDatagramPacket_initWithByteArray_withInt_withInt_withJavaNetInetAddress_withInt_(bytes, 0, length, receiverAddress, contactPort);
    [datagramSock sendWithJavaNetDatagramPacket:dgPacket];
    [datagramSock close];
    return nil;
  }
}

- (void)leaveIOCriticalSectionWithNSString:(NSString *)key {
  AndroidGovNistJavaxSipStackIOHandler_leaveIOCriticalSectionWithNSString_(self, key);
}

- (void)enterIOCriticalSectionWithNSString:(NSString *)key {
  AndroidGovNistJavaxSipStackIOHandler_enterIOCriticalSectionWithNSString_(self, key);
}

- (void)closeAll {
  [((id<OrgSlf4jLogger>) nil_chk(AndroidGovNistJavaxSipStackIOHandler_logger)) debugWithNSString:JreStrcat("$I$", @"Closing ", [((JavaUtilConcurrentConcurrentHashMap *) nil_chk(socketTable_)) size], @" sockets from IOHandler")];
  for (id<JavaUtilEnumeration> values = [socketTable_ elements]; [((id<JavaUtilEnumeration>) nil_chk(values)) hasMoreElements]; ) {
    JavaNetSocket *s = [values nextElement];
    @try {
      [((JavaNetSocket *) nil_chk(s)) close];
    }
    @catch (JavaIoIOException *ex) {
    }
  }
}

- (void)dealloc {
  RELEASE_(sipStack_);
  RELEASE_(socketTable_);
  RELEASE_(socketCreationMap_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, "LNSString;", 0xc, 0, 1, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0xc, 0, 2, -1, -1, -1, -1 },
    { NULL, NULL, 0x4, -1, 3, -1, -1, -1, -1 },
    { NULL, "V", 0x4, 4, 5, -1, -1, -1, -1 },
    { NULL, "LJavaNetSocket;", 0x4, 6, 7, -1, -1, -1, -1 },
    { NULL, "V", 0x4, 8, 7, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 9, 10, 11, -1, -1, -1 },
    { NULL, "LJavaNetSocketAddress;", 0x1, 12, 13, 11, -1, -1, -1 },
    { NULL, "LJavaNetSocketAddress;", 0x1, 14, 15, 11, -1, -1, -1 },
    { NULL, "LJavaNetSocket;", 0x1, 16, 17, 11, -1, -1, -1 },
    { NULL, "V", 0x2, 18, 7, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 19, 7, 11, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(makeKeyWithJavaNetInetAddress:withInt:);
  methods[1].selector = @selector(makeKeyWithNSString:withInt:);
  methods[2].selector = @selector(initWithAndroidGovNistJavaxSipStackSIPTransactionStack:);
  methods[3].selector = @selector(putSocketWithNSString:withJavaNetSocket:);
  methods[4].selector = @selector(getSocketWithNSString:);
  methods[5].selector = @selector(removeSocketWithNSString:);
  methods[6].selector = @selector(writeChunksWithJavaIoOutputStream:withByteArray:withInt:);
  methods[7].selector = @selector(getLocalAddressForTcpDstWithJavaNetInetAddress:withInt:withJavaNetInetAddress:withInt:);
  methods[8].selector = @selector(getLocalAddressForTlsDstWithJavaNetInetAddress:withInt:withJavaNetInetAddress:withAndroidGovNistJavaxSipStackTLSMessageChannel:);
  methods[9].selector = @selector(sendBytesWithJavaNetInetAddress:withJavaNetInetAddress:withInt:withNSString:withByteArray:withBoolean:withAndroidGovNistJavaxSipStackMessageChannel:);
  methods[10].selector = @selector(leaveIOCriticalSectionWithNSString:);
  methods[11].selector = @selector(enterIOCriticalSectionWithNSString:);
  methods[12].selector = @selector(closeAll);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "logger", "LOrgSlf4jLogger;", .constantValue.asLong = 0, 0xa, -1, 20, -1, -1 },
    { "sipStack_", "LAndroidGovNistJavaxSipSipStackImpl;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "TCP", "LNSString;", .constantValue.asLong = 0, 0x1a, -1, 21, -1, -1 },
    { "TLS", "LNSString;", .constantValue.asLong = 0, 0x1a, -1, 22, -1, -1 },
    { "socketTable_", "LJavaUtilConcurrentConcurrentHashMap;", .constantValue.asLong = 0, 0x12, -1, -1, 23, -1 },
    { "socketCreationMap_", "LJavaUtilConcurrentConcurrentHashMap;", .constantValue.asLong = 0, 0x12, -1, -1, 24, -1 },
  };
  static const void *ptrTable[] = { "makeKey", "LJavaNetInetAddress;I", "LNSString;I", "LAndroidGovNistJavaxSipStackSIPTransactionStack;", "putSocket", "LNSString;LJavaNetSocket;", "getSocket", "LNSString;", "removeSocket", "writeChunks", "LJavaIoOutputStream;[BI", "LJavaIoIOException;", "getLocalAddressForTcpDst", "LJavaNetInetAddress;ILJavaNetInetAddress;I", "getLocalAddressForTlsDst", "LJavaNetInetAddress;ILJavaNetInetAddress;LAndroidGovNistJavaxSipStackTLSMessageChannel;", "sendBytes", "LJavaNetInetAddress;LJavaNetInetAddress;ILNSString;[BZLAndroidGovNistJavaxSipStackMessageChannel;", "leaveIOCriticalSection", "enterIOCriticalSection", &AndroidGovNistJavaxSipStackIOHandler_logger, &AndroidGovNistJavaxSipStackIOHandler_TCP, &AndroidGovNistJavaxSipStackIOHandler_TLS, "Ljava/util/concurrent/ConcurrentHashMap<Ljava/lang/String;Ljava/net/Socket;>;", "Ljava/util/concurrent/ConcurrentHashMap<Ljava/lang/String;Ljava/util/concurrent/Semaphore;>;" };
  static const J2ObjcClassInfo _AndroidGovNistJavaxSipStackIOHandler = { "IOHandler", "android.gov.nist.javax.sip.stack", ptrTable, methods, fields, 7, 0x1, 13, 6, -1, -1, -1, -1, -1 };
  return &_AndroidGovNistJavaxSipStackIOHandler;
}

+ (void)initialize {
  if (self == [AndroidGovNistJavaxSipStackIOHandler class]) {
    JreStrongAssign(&AndroidGovNistJavaxSipStackIOHandler_logger, OrgSlf4jLoggerFactory_getLoggerWithIOSClass_(AndroidGovNistJavaxSipStackIOHandler_class_()));
    J2OBJC_SET_INITIALIZED(AndroidGovNistJavaxSipStackIOHandler)
  }
}

@end

NSString *AndroidGovNistJavaxSipStackIOHandler_makeKeyWithJavaNetInetAddress_withInt_(JavaNetInetAddress *addr, jint port) {
  AndroidGovNistJavaxSipStackIOHandler_initialize();
  return JreStrcat("$CI", [((JavaNetInetAddress *) nil_chk(addr)) getHostAddress], ':', port);
}

NSString *AndroidGovNistJavaxSipStackIOHandler_makeKeyWithNSString_withInt_(NSString *addr, jint port) {
  AndroidGovNistJavaxSipStackIOHandler_initialize();
  return JreStrcat("$CI", addr, ':', port);
}

void AndroidGovNistJavaxSipStackIOHandler_initWithAndroidGovNistJavaxSipStackSIPTransactionStack_(AndroidGovNistJavaxSipStackIOHandler *self, AndroidGovNistJavaxSipStackSIPTransactionStack *sipStack) {
  NSObject_init(self);
  JreStrongAssignAndConsume(&self->socketTable_, new_JavaUtilConcurrentConcurrentHashMap_init());
  JreStrongAssignAndConsume(&self->socketCreationMap_, new_JavaUtilConcurrentConcurrentHashMap_init());
  JreStrongAssign(&self->sipStack_, (AndroidGovNistJavaxSipSipStackImpl *) cast_chk(sipStack, [AndroidGovNistJavaxSipSipStackImpl class]));
}

AndroidGovNistJavaxSipStackIOHandler *new_AndroidGovNistJavaxSipStackIOHandler_initWithAndroidGovNistJavaxSipStackSIPTransactionStack_(AndroidGovNistJavaxSipStackSIPTransactionStack *sipStack) {
  J2OBJC_NEW_IMPL(AndroidGovNistJavaxSipStackIOHandler, initWithAndroidGovNistJavaxSipStackSIPTransactionStack_, sipStack)
}

AndroidGovNistJavaxSipStackIOHandler *create_AndroidGovNistJavaxSipStackIOHandler_initWithAndroidGovNistJavaxSipStackSIPTransactionStack_(AndroidGovNistJavaxSipStackSIPTransactionStack *sipStack) {
  J2OBJC_CREATE_IMPL(AndroidGovNistJavaxSipStackIOHandler, initWithAndroidGovNistJavaxSipStackSIPTransactionStack_, sipStack)
}

void AndroidGovNistJavaxSipStackIOHandler_writeChunksWithJavaIoOutputStream_withByteArray_withInt_(AndroidGovNistJavaxSipStackIOHandler *self, JavaIoOutputStream *outputStream, IOSByteArray *bytes, jint length) {
  @synchronized(outputStream) {
    jint chunksize = 8 * 1024;
    for (jint p = 0; p < length; p += chunksize) {
      jint chunk = p + chunksize < length ? chunksize : length - p;
      [((JavaIoOutputStream *) nil_chk(outputStream)) writeWithByteArray:bytes withInt:p withInt:chunk];
    }
  }
  [((JavaIoOutputStream *) nil_chk(outputStream)) flush];
}

void AndroidGovNistJavaxSipStackIOHandler_leaveIOCriticalSectionWithNSString_(AndroidGovNistJavaxSipStackIOHandler *self, NSString *key) {
  JavaUtilConcurrentSemaphore *creationSemaphore = [((JavaUtilConcurrentConcurrentHashMap *) nil_chk(self->socketCreationMap_)) getWithId:key];
  if (creationSemaphore != nil) {
    [creationSemaphore release__];
  }
}

void AndroidGovNistJavaxSipStackIOHandler_enterIOCriticalSectionWithNSString_(AndroidGovNistJavaxSipStackIOHandler *self, NSString *key) {
  JavaUtilConcurrentSemaphore *creationSemaphore = [((JavaUtilConcurrentConcurrentHashMap *) nil_chk(self->socketCreationMap_)) getWithId:key];
  if (creationSemaphore == nil) {
    JavaUtilConcurrentSemaphore *newCreationSemaphore = create_JavaUtilConcurrentSemaphore_initWithInt_withBoolean_(1, true);
    creationSemaphore = [self->socketCreationMap_ putIfAbsentWithId:key withId:newCreationSemaphore];
    if (creationSemaphore == nil) {
      creationSemaphore = newCreationSemaphore;
      [((id<OrgSlf4jLogger>) nil_chk(AndroidGovNistJavaxSipStackIOHandler_logger)) debugWithNSString:JreStrcat("$$", @"new Semaphore added for key ", key)];
    }
  }
  @try {
    jboolean retval = [creationSemaphore tryAcquireWithLong:10 withJavaUtilConcurrentTimeUnit:JreLoadEnum(JavaUtilConcurrentTimeUnit, SECONDS)];
    if (!retval) {
      @throw create_JavaIoIOException_initWithNSString_(JreStrcat("$$$", @"Could not acquire IO Semaphore'", key, @"' after 10 seconds -- giving up "));
    }
  }
  @catch (JavaLangInterruptedException *e) {
    @throw create_JavaIoIOException_initWithNSString_(@"exception in acquiring sem");
  }
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(AndroidGovNistJavaxSipStackIOHandler)
