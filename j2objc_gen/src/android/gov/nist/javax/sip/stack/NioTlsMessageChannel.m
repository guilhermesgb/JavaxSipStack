//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: ./src/android/gov/nist/javax/sip/stack/NioTlsMessageChannel.java
//

#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "android/gov/nist/javax/sip/SipStackImpl.h"
#include "android/gov/nist/javax/sip/parser/NioPipelineParser.h"
#include "android/gov/nist/javax/sip/stack/ByteBufferFactory.h"
#include "android/gov/nist/javax/sip/stack/HandshakeCompletedListenerImpl.h"
#include "android/gov/nist/javax/sip/stack/MessageProcessor.h"
#include "android/gov/nist/javax/sip/stack/NIOHandler.h"
#include "android/gov/nist/javax/sip/stack/NioTcpMessageChannel.h"
#include "android/gov/nist/javax/sip/stack/NioTcpMessageProcessor.h"
#include "android/gov/nist/javax/sip/stack/NioTlsMessageChannel.h"
#include "android/gov/nist/javax/sip/stack/NioTlsMessageProcessor.h"
#include "android/gov/nist/javax/sip/stack/SIPTransactionStack.h"
#include "android/gov/nist/javax/sip/stack/SSLStateMachine.h"
#include "java/io/IOException.h"
#include "java/io/InputStream.h"
#include "java/lang/Exception.h"
#include "java/lang/RuntimeException.h"
#include "java/lang/System.h"
#include "java/net/InetAddress.h"
#include "java/net/Socket.h"
#include "java/nio/ByteBuffer.h"
#include "java/nio/channels/SocketChannel.h"
#include "java/util/HashMap.h"
#include "java/util/Properties.h"
#include "javax/net/ssl/HandshakeCompletedListener.h"
#include "javax/net/ssl/SSLContext.h"
#include "javax/net/ssl/SSLEngine.h"
#include "javax/net/ssl/SSLSession.h"
#include "org/slf4j/Logger.h"
#include "org/slf4j/LoggerFactory.h"

static void (*AndroidGovNistJavaxSipStackNioTlsMessageChannel_super$_sendMessageWithByteArray_withBoolean_)(id, SEL, id, jboolean);

static void (*AndroidGovNistJavaxSipStackNioTlsMessageChannel_super$_sendMessageWithByteArray_withJavaNetInetAddress_withInt_withBoolean_)(id, SEL, id, id, jint, jboolean);

#pragma clang diagnostic ignored "-Wincomplete-implementation"

@interface AndroidGovNistJavaxSipStackNioTlsMessageChannel () {
 @public
  id<JavaxNetSslHandshakeCompletedListener> handshakeCompletedListener_;
  jboolean handshakeCompleted_;
  jint appBufferMax_;
  jint netBufferMax_;
}

- (void)checkSocketState;

@end

J2OBJC_FIELD_SETTER(AndroidGovNistJavaxSipStackNioTlsMessageChannel, handshakeCompletedListener_, id<JavaxNetSslHandshakeCompletedListener>)

inline id<OrgSlf4jLogger> AndroidGovNistJavaxSipStackNioTlsMessageChannel_get_logger();
inline id<OrgSlf4jLogger> AndroidGovNistJavaxSipStackNioTlsMessageChannel_set_logger(id<OrgSlf4jLogger> value);
static id<OrgSlf4jLogger> AndroidGovNistJavaxSipStackNioTlsMessageChannel_logger;
J2OBJC_STATIC_FIELD_OBJ(AndroidGovNistJavaxSipStackNioTlsMessageChannel, logger, id<OrgSlf4jLogger>)

__attribute__((unused)) static void AndroidGovNistJavaxSipStackNioTlsMessageChannel_checkSocketState(AndroidGovNistJavaxSipStackNioTlsMessageChannel *self);

inline jlong AndroidGovNistJavaxSipStackNioTlsMessageChannel_SSLReconnectedException_get_serialVersionUID();
#define AndroidGovNistJavaxSipStackNioTlsMessageChannel_SSLReconnectedException_serialVersionUID 1LL
J2OBJC_STATIC_FIELD_CONSTANT(AndroidGovNistJavaxSipStackNioTlsMessageChannel_SSLReconnectedException, serialVersionUID, jlong)

@interface AndroidGovNistJavaxSipStackNioTlsMessageChannel_1 : NSObject < AndroidGovNistJavaxSipStackSSLStateMachine_MessageSendCallback > {
 @public
  AndroidGovNistJavaxSipStackNioTlsMessageChannel *this$0_;
  jboolean val$isClient_;
}

- (instancetype)initWithAndroidGovNistJavaxSipStackNioTlsMessageChannel:(AndroidGovNistJavaxSipStackNioTlsMessageChannel *)outer$
                                                            withBoolean:(jboolean)capture$0;

- (void)doSendWithByteArray:(IOSByteArray *)bytes;

@end

J2OBJC_EMPTY_STATIC_INIT(AndroidGovNistJavaxSipStackNioTlsMessageChannel_1)

__attribute__((unused)) static void AndroidGovNistJavaxSipStackNioTlsMessageChannel_1_initWithAndroidGovNistJavaxSipStackNioTlsMessageChannel_withBoolean_(AndroidGovNistJavaxSipStackNioTlsMessageChannel_1 *self, AndroidGovNistJavaxSipStackNioTlsMessageChannel *outer$, jboolean capture$0);

__attribute__((unused)) static AndroidGovNistJavaxSipStackNioTlsMessageChannel_1 *new_AndroidGovNistJavaxSipStackNioTlsMessageChannel_1_initWithAndroidGovNistJavaxSipStackNioTlsMessageChannel_withBoolean_(AndroidGovNistJavaxSipStackNioTlsMessageChannel *outer$, jboolean capture$0) NS_RETURNS_RETAINED;

__attribute__((unused)) static AndroidGovNistJavaxSipStackNioTlsMessageChannel_1 *create_AndroidGovNistJavaxSipStackNioTlsMessageChannel_1_initWithAndroidGovNistJavaxSipStackNioTlsMessageChannel_withBoolean_(AndroidGovNistJavaxSipStackNioTlsMessageChannel *outer$, jboolean capture$0);

@interface AndroidGovNistJavaxSipStackNioTlsMessageChannel_2 : NSObject < AndroidGovNistJavaxSipStackSSLStateMachine_MessageSendCallback > {
 @public
  AndroidGovNistJavaxSipStackNioTlsMessageChannel *this$0_;
  JavaNetInetAddress *val$receiverAddress_;
  jint val$receiverPort_;
  jboolean val$retry_;
}

- (instancetype)initWithAndroidGovNistJavaxSipStackNioTlsMessageChannel:(AndroidGovNistJavaxSipStackNioTlsMessageChannel *)outer$
                                                 withJavaNetInetAddress:(JavaNetInetAddress *)capture$0
                                                                withInt:(jint)capture$1
                                                            withBoolean:(jboolean)capture$2;

- (void)doSendWithByteArray:(IOSByteArray *)bytes;

@end

J2OBJC_EMPTY_STATIC_INIT(AndroidGovNistJavaxSipStackNioTlsMessageChannel_2)

__attribute__((unused)) static void AndroidGovNistJavaxSipStackNioTlsMessageChannel_2_initWithAndroidGovNistJavaxSipStackNioTlsMessageChannel_withJavaNetInetAddress_withInt_withBoolean_(AndroidGovNistJavaxSipStackNioTlsMessageChannel_2 *self, AndroidGovNistJavaxSipStackNioTlsMessageChannel *outer$, JavaNetInetAddress *capture$0, jint capture$1, jboolean capture$2);

__attribute__((unused)) static AndroidGovNistJavaxSipStackNioTlsMessageChannel_2 *new_AndroidGovNistJavaxSipStackNioTlsMessageChannel_2_initWithAndroidGovNistJavaxSipStackNioTlsMessageChannel_withJavaNetInetAddress_withInt_withBoolean_(AndroidGovNistJavaxSipStackNioTlsMessageChannel *outer$, JavaNetInetAddress *capture$0, jint capture$1, jboolean capture$2) NS_RETURNS_RETAINED;

__attribute__((unused)) static AndroidGovNistJavaxSipStackNioTlsMessageChannel_2 *create_AndroidGovNistJavaxSipStackNioTlsMessageChannel_2_initWithAndroidGovNistJavaxSipStackNioTlsMessageChannel_withJavaNetInetAddress_withInt_withBoolean_(AndroidGovNistJavaxSipStackNioTlsMessageChannel *outer$, JavaNetInetAddress *capture$0, jint capture$1, jboolean capture$2);

J2OBJC_INITIALIZED_DEFN(AndroidGovNistJavaxSipStackNioTlsMessageChannel)

@implementation AndroidGovNistJavaxSipStackNioTlsMessageChannel

+ (AndroidGovNistJavaxSipStackNioTcpMessageChannel *)createWithAndroidGovNistJavaxSipStackNioTcpMessageProcessor:(AndroidGovNistJavaxSipStackNioTcpMessageProcessor *)nioTcpMessageProcessor
                                                                                withJavaNioChannelsSocketChannel:(JavaNioChannelsSocketChannel *)socketChannel {
  return AndroidGovNistJavaxSipStackNioTlsMessageChannel_createWithAndroidGovNistJavaxSipStackNioTcpMessageProcessor_withJavaNioChannelsSocketChannel_(nioTcpMessageProcessor, socketChannel);
}

- (instancetype)initWithAndroidGovNistJavaxSipStackNioTcpMessageProcessor:(AndroidGovNistJavaxSipStackNioTcpMessageProcessor *)nioTcpMessageProcessor
                                         withJavaNioChannelsSocketChannel:(JavaNioChannelsSocketChannel *)socketChannel {
  AndroidGovNistJavaxSipStackNioTlsMessageChannel_initWithAndroidGovNistJavaxSipStackNioTcpMessageProcessor_withJavaNioChannelsSocketChannel_(self, nioTcpMessageProcessor, socketChannel);
  return self;
}

- (void)init__WithBoolean:(jboolean)clientMode {
  JavaxNetSslSSLContext *ctx = clientMode ? ((AndroidGovNistJavaxSipStackNioTlsMessageProcessor *) nil_chk(((AndroidGovNistJavaxSipStackNioTlsMessageProcessor *) cast_chk(messageProcessor_, [AndroidGovNistJavaxSipStackNioTlsMessageProcessor class]))))->sslClientCtx_ : ((AndroidGovNistJavaxSipStackNioTlsMessageProcessor *) nil_chk(((AndroidGovNistJavaxSipStackNioTlsMessageProcessor *) cast_chk(messageProcessor_, [AndroidGovNistJavaxSipStackNioTlsMessageProcessor class]))))->sslServerCtx_;
  JreStrongAssignAndConsume(&sslStateMachine_, new_AndroidGovNistJavaxSipStackSSLStateMachine_initWithJavaxNetSslSSLEngine_withAndroidGovNistJavaxSipStackNioTlsChannelInterface_([ctx createSSLEngine], self));
  [((JavaxNetSslSSLEngine *) nil_chk(sslStateMachine_->sslEngine_)) setUseClientModeWithBoolean:clientMode];
  NSString *auth = [((JavaUtilProperties *) nil_chk([((AndroidGovNistJavaxSipSipStackImpl *) nil_chk(((AndroidGovNistJavaxSipSipStackImpl *) cast_chk(sipStack_, [AndroidGovNistJavaxSipSipStackImpl class])))) getConfigurationProperties])) getPropertyWithNSString:@"gov.nist.javax.sip.TLS_CLIENT_AUTH_TYPE"];
  if (auth == nil) {
    auth = @"Enabled";
  }
  if ([auth isEqual:@"Disabled"] || [auth isEqual:@"DisabledAll"]) {
    [((JavaxNetSslSSLEngine *) nil_chk(((AndroidGovNistJavaxSipStackSSLStateMachine *) nil_chk(sslStateMachine_))->sslEngine_)) setNeedClientAuthWithBoolean:false];
    [((JavaxNetSslSSLEngine *) nil_chk(((AndroidGovNistJavaxSipStackSSLStateMachine *) nil_chk(sslStateMachine_))->sslEngine_)) setWantClientAuthWithBoolean:false];
  }
  else if ([auth isEqual:@"Enabled"]) {
    [((JavaxNetSslSSLEngine *) nil_chk(((AndroidGovNistJavaxSipStackSSLStateMachine *) nil_chk(sslStateMachine_))->sslEngine_)) setNeedClientAuthWithBoolean:true];
  }
  else if ([auth isEqual:@"Want"]) {
    [((JavaxNetSslSSLEngine *) nil_chk(((AndroidGovNistJavaxSipStackSSLStateMachine *) nil_chk(sslStateMachine_))->sslEngine_)) setNeedClientAuthWithBoolean:false];
    [((JavaxNetSslSSLEngine *) nil_chk(((AndroidGovNistJavaxSipStackSSLStateMachine *) nil_chk(sslStateMachine_))->sslEngine_)) setWantClientAuthWithBoolean:true];
  }
  else {
    @throw create_JavaLangRuntimeException_initWithNSString_(JreStrcat("$$", @"Invalid parameter for TLS authentication: ", auth));
  }
  [((JavaxNetSslSSLEngine *) nil_chk(((AndroidGovNistJavaxSipStackSSLStateMachine *) nil_chk(sslStateMachine_))->sslEngine_)) setEnabledProtocolsWithNSStringArray:[((AndroidGovNistJavaxSipSipStackImpl *) nil_chk(((AndroidGovNistJavaxSipSipStackImpl *) cast_chk(sipStack_, [AndroidGovNistJavaxSipSipStackImpl class])))) getEnabledProtocols]];
  if ([self getHandshakeCompletedListener] == nil) {
    AndroidGovNistJavaxSipStackHandshakeCompletedListenerImpl *listner = create_AndroidGovNistJavaxSipStackHandshakeCompletedListenerImpl_initWithAndroidGovNistJavaxSipStackNioTlsMessageChannel_withJavaNioChannelsSocketChannel_(self, [self getSocketChannel]);
    [self setHandshakeCompletedListenerWithJavaxNetSslHandshakeCompletedListener:listner];
  }
}

- (JavaNioByteBuffer *)prepareEncryptedDataBuffer {
  return [((AndroidGovNistJavaxSipStackByteBufferFactory *) nil_chk(AndroidGovNistJavaxSipStackByteBufferFactory_getInstance())) allocateDirectWithInt:netBufferMax_];
}

- (JavaNioByteBuffer *)prepareAppDataBuffer {
  return [((AndroidGovNistJavaxSipStackByteBufferFactory *) nil_chk(AndroidGovNistJavaxSipStackByteBufferFactory_getInstance())) allocateDirectWithInt:appBufferMax_];
}

- (JavaNioByteBuffer *)prepareAppDataBufferWithInt:(jint)capacity {
  return [((AndroidGovNistJavaxSipStackByteBufferFactory *) nil_chk(AndroidGovNistJavaxSipStackByteBufferFactory_getInstance())) allocateDirectWithInt:capacity];
}

- (void)sendMessageWithByteArray:(IOSByteArray *)msg
                     withBoolean:(jboolean)isClient {
  AndroidGovNistJavaxSipStackNioTlsMessageChannel_checkSocketState(self);
  JavaNioByteBuffer *b = JavaNioByteBuffer_wrapWithByteArray_(msg);
  @try {
    [((AndroidGovNistJavaxSipStackSSLStateMachine *) nil_chk(sslStateMachine_)) wrapWithJavaNioByteBuffer:b withJavaNioByteBuffer:[((AndroidGovNistJavaxSipStackByteBufferFactory *) nil_chk(AndroidGovNistJavaxSipStackByteBufferFactory_getInstance())) allocateDirectWithInt:netBufferMax_] withAndroidGovNistJavaxSipStackSSLStateMachine_MessageSendCallback:create_AndroidGovNistJavaxSipStackNioTlsMessageChannel_1_initWithAndroidGovNistJavaxSipStackNioTlsMessageChannel_withBoolean_(self, isClient)];
  }
  @catch (JavaLangException *e) {
    @throw create_JavaIoIOException_initWithNSString_withNSException_(@"Can't send message", e);
  }
}

- (void)sendEncryptedDataWithByteArray:(IOSByteArray *)msg {
  [((id<OrgSlf4jLogger>) nil_chk(AndroidGovNistJavaxSipStackNioTlsMessageChannel_logger)) debugWithNSString:JreStrcat("$@$I$@", @"sendEncryptedData  this = ", self, @" peerPort = ", peerPort_, @" addr = ", peerAddress_)];
  lastActivityTimeStamp_ = JavaLangSystem_currentTimeMillis();
  AndroidGovNistJavaxSipStackNIOHandler *nioHandler = ((AndroidGovNistJavaxSipStackNioTcpMessageProcessor *) nil_chk(((AndroidGovNistJavaxSipStackNioTcpMessageProcessor *) cast_chk(messageProcessor_, [AndroidGovNistJavaxSipStackNioTcpMessageProcessor class]))))->nioHandler_;
  if (self->socketChannel_ != nil && [self->socketChannel_ isConnected] && [((JavaNioChannelsSocketChannel *) nil_chk(self->socketChannel_)) isOpen]) {
    [((AndroidGovNistJavaxSipStackNIOHandler *) nil_chk(nioHandler)) putSocketWithNSString:AndroidGovNistJavaxSipStackNIOHandler_makeKeyWithJavaNetInetAddress_withInt_(self->peerAddress_, self->peerPort_) withJavaNioChannelsSocketChannel:self->socketChannel_];
  }
  [super sendMessageWithByteArray:msg withJavaNetInetAddress:self->peerAddress_ withInt:self->peerPort_ withBoolean:true];
}

- (void)sendMessageWithByteArray:(IOSByteArray *)message
          withJavaNetInetAddress:(JavaNetInetAddress *)receiverAddress
                         withInt:(jint)receiverPort
                     withBoolean:(jboolean)retry {
  AndroidGovNistJavaxSipStackNioTlsMessageChannel_checkSocketState(self);
  JavaNioByteBuffer *b = JavaNioByteBuffer_wrapWithByteArray_(message);
  @try {
    [((AndroidGovNistJavaxSipStackSSLStateMachine *) nil_chk(sslStateMachine_)) wrapWithJavaNioByteBuffer:b withJavaNioByteBuffer:[((AndroidGovNistJavaxSipStackByteBufferFactory *) nil_chk(AndroidGovNistJavaxSipStackByteBufferFactory_getInstance())) allocateDirectWithInt:netBufferMax_] withAndroidGovNistJavaxSipStackSSLStateMachine_MessageSendCallback:create_AndroidGovNistJavaxSipStackNioTlsMessageChannel_2_initWithAndroidGovNistJavaxSipStackNioTlsMessageChannel_withJavaNetInetAddress_withInt_withBoolean_(self, receiverAddress, receiverPort, retry)];
  }
  @catch (JavaIoIOException *e) {
    @throw e;
  }
}

- (void)createBuffers {
  id<JavaxNetSslSSLSession> session = [((JavaxNetSslSSLEngine *) nil_chk(((AndroidGovNistJavaxSipStackSSLStateMachine *) nil_chk(sslStateMachine_))->sslEngine_)) getSession];
  appBufferMax_ = [((id<JavaxNetSslSSLSession>) nil_chk(session)) getApplicationBufferSize];
  netBufferMax_ = [session getPacketBufferSize];
  [((id<OrgSlf4jLogger>) nil_chk(AndroidGovNistJavaxSipStackNioTlsMessageChannel_logger)) debugWithNSString:JreStrcat("$I$I", @"appBufferMax=", appBufferMax_, @" netBufferMax=", netBufferMax_)];
}

- (instancetype)initWithJavaNetInetAddress:(JavaNetInetAddress *)inetAddress
                                   withInt:(jint)port
withAndroidGovNistJavaxSipStackSIPTransactionStack:(AndroidGovNistJavaxSipStackSIPTransactionStack *)sipStack
withAndroidGovNistJavaxSipStackNioTcpMessageProcessor:(AndroidGovNistJavaxSipStackNioTcpMessageProcessor *)nioTcpMessageProcessor {
  AndroidGovNistJavaxSipStackNioTlsMessageChannel_initWithJavaNetInetAddress_withInt_withAndroidGovNistJavaxSipStackSIPTransactionStack_withAndroidGovNistJavaxSipStackNioTcpMessageProcessor_(self, inetAddress, port, sipStack, nioTcpMessageProcessor);
  return self;
}

- (void)addBytesWithByteArray:(IOSByteArray *)bytes {
  [((id<OrgSlf4jLogger>) nil_chk(AndroidGovNistJavaxSipStackNioTlsMessageChannel_logger)) debugWithNSString:JreStrcat("$I", @"Adding TLS bytes for decryption ", ((IOSByteArray *) nil_chk(bytes))->size_)];
  if (bytes->size_ <= 0) return;
  JavaNioByteBuffer *buffer = JavaNioByteBuffer_wrapWithByteArray_(bytes);
  [((AndroidGovNistJavaxSipStackSSLStateMachine *) nil_chk(sslStateMachine_)) unwrapWithJavaNioByteBuffer:buffer];
}

- (NSString *)getTransport {
  return @"TLS";
}

- (void)onNewSocketWithByteArray:(IOSByteArray *)message {
  [super onNewSocketWithByteArray:message];
  @try {
    NSString *last = nil;
    if (message != nil) {
      last = [NSString java_stringWithBytes:message charsetName:@"UTF-8"];
    }
    [((id<OrgSlf4jLogger>) nil_chk(AndroidGovNistJavaxSipStackNioTlsMessageChannel_logger)) debugWithNSString:JreStrcat("$@$$", @"New socket for ", self, @" last message = ", last)];
    [self init__WithBoolean:true];
    [self createBuffers];
    [self sendMessageWithByteArray:message withBoolean:false];
  }
  @catch (JavaLangException *e) {
    [((id<OrgSlf4jLogger>) nil_chk(AndroidGovNistJavaxSipStackNioTlsMessageChannel_logger)) errorWithNSString:@"Cant reinit" withNSException:e];
  }
}

- (void)checkSocketState {
  AndroidGovNistJavaxSipStackNioTlsMessageChannel_checkSocketState(self);
}

- (jboolean)isSecure {
  return true;
}

- (void)addPlaintextBytesWithByteArray:(IOSByteArray *)bytes {
  [((AndroidGovNistJavaxSipParserNioPipelineParser *) nil_chk(nioParser_)) addBytesWithByteArray:bytes];
}

- (void)setHandshakeCompletedListenerWithJavaxNetSslHandshakeCompletedListener:(id<JavaxNetSslHandshakeCompletedListener>)handshakeCompletedListenerImpl {
  JreStrongAssign(&self->handshakeCompletedListener_, handshakeCompletedListenerImpl);
}

- (AndroidGovNistJavaxSipStackHandshakeCompletedListenerImpl *)getHandshakeCompletedListener {
  return (AndroidGovNistJavaxSipStackHandshakeCompletedListenerImpl *) cast_chk(handshakeCompletedListener_, [AndroidGovNistJavaxSipStackHandshakeCompletedListenerImpl class]);
}

- (jboolean)isHandshakeCompleted {
  return handshakeCompleted_;
}

- (void)setHandshakeCompletedWithBoolean:(jboolean)handshakeCompleted {
  self->handshakeCompleted_ = handshakeCompleted;
}

- (AndroidGovNistJavaxSipSipStackImpl *)getSIPStack {
  return (AndroidGovNistJavaxSipSipStackImpl *) cast_chk([super getSIPStack], [AndroidGovNistJavaxSipSipStackImpl class]);
}

- (void)dealloc {
  RELEASE_(sslStateMachine_);
  RELEASE_(handshakeCompletedListener_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, "LAndroidGovNistJavaxSipStackNioTcpMessageChannel;", 0x9, 0, 1, 2, -1, -1, -1 },
    { NULL, NULL, 0x4, -1, 1, 2, -1, -1, -1 },
    { NULL, "V", 0x1, 3, 4, 5, -1, -1, -1 },
    { NULL, "LJavaNioByteBuffer;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LJavaNioByteBuffer;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LJavaNioByteBuffer;", 0x1, 6, 7, -1, -1, -1, -1 },
    { NULL, "V", 0x4, 8, 9, 2, -1, -1, -1 },
    { NULL, "V", 0x1, 10, 11, 2, -1, -1, -1 },
    { NULL, "V", 0x1, 8, 12, 2, -1, -1, -1 },
    { NULL, "V", 0x4, -1, -1, -1, -1, -1, -1 },
    { NULL, NULL, 0x1, -1, 13, 2, -1, -1, -1 },
    { NULL, "V", 0x4, 14, 11, 15, -1, -1, -1 },
    { NULL, "LNSString;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 16, 11, -1, -1, -1, -1 },
    { NULL, "V", 0x2, -1, -1, 2, -1, -1, -1 },
    { NULL, "Z", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 17, 11, 15, -1, -1, -1 },
    { NULL, "V", 0x1, 18, 19, -1, -1, -1, -1 },
    { NULL, "LAndroidGovNistJavaxSipStackHandshakeCompletedListenerImpl;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 20, 4, -1, -1, -1, -1 },
    { NULL, "LAndroidGovNistJavaxSipSipStackImpl;", 0x1, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(createWithAndroidGovNistJavaxSipStackNioTcpMessageProcessor:withJavaNioChannelsSocketChannel:);
  methods[1].selector = @selector(initWithAndroidGovNistJavaxSipStackNioTcpMessageProcessor:withJavaNioChannelsSocketChannel:);
  methods[2].selector = @selector(init__WithBoolean:);
  methods[3].selector = @selector(prepareEncryptedDataBuffer);
  methods[4].selector = @selector(prepareAppDataBuffer);
  methods[5].selector = @selector(prepareAppDataBufferWithInt:);
  methods[6].selector = @selector(sendMessageWithByteArray:withBoolean:);
  methods[7].selector = @selector(sendEncryptedDataWithByteArray:);
  methods[8].selector = @selector(sendMessageWithByteArray:withJavaNetInetAddress:withInt:withBoolean:);
  methods[9].selector = @selector(createBuffers);
  methods[10].selector = @selector(initWithJavaNetInetAddress:withInt:withAndroidGovNistJavaxSipStackSIPTransactionStack:withAndroidGovNistJavaxSipStackNioTcpMessageProcessor:);
  methods[11].selector = @selector(addBytesWithByteArray:);
  methods[12].selector = @selector(getTransport);
  methods[13].selector = @selector(onNewSocketWithByteArray:);
  methods[14].selector = @selector(checkSocketState);
  methods[15].selector = @selector(isSecure);
  methods[16].selector = @selector(addPlaintextBytesWithByteArray:);
  methods[17].selector = @selector(setHandshakeCompletedListenerWithJavaxNetSslHandshakeCompletedListener:);
  methods[18].selector = @selector(getHandshakeCompletedListener);
  methods[19].selector = @selector(isHandshakeCompleted);
  methods[20].selector = @selector(setHandshakeCompletedWithBoolean:);
  methods[21].selector = @selector(getSIPStack);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "logger", "LOrgSlf4jLogger;", .constantValue.asLong = 0, 0xa, -1, 21, -1, -1 },
    { "sslStateMachine_", "LAndroidGovNistJavaxSipStackSSLStateMachine;", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "handshakeCompletedListener_", "LJavaxNetSslHandshakeCompletedListener;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "handshakeCompleted_", "Z", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "appBufferMax_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "netBufferMax_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "create", "LAndroidGovNistJavaxSipStackNioTcpMessageProcessor;LJavaNioChannelsSocketChannel;", "LJavaIoIOException;", "init", "Z", "LJavaLangException;LJavaSecurityCertCertificateException;LJavaIoFileNotFoundException;LJavaIoIOException;", "prepareAppDataBuffer", "I", "sendMessage", "[BZ", "sendEncryptedData", "[B", "[BLJavaNetInetAddress;IZ", "LJavaNetInetAddress;ILAndroidGovNistJavaxSipStackSIPTransactionStack;LAndroidGovNistJavaxSipStackNioTcpMessageProcessor;", "addBytes", "LJavaLangException;", "onNewSocket", "addPlaintextBytes", "setHandshakeCompletedListener", "LJavaxNetSslHandshakeCompletedListener;", "setHandshakeCompleted", &AndroidGovNistJavaxSipStackNioTlsMessageChannel_logger, "LAndroidGovNistJavaxSipStackNioTlsMessageChannel_SSLReconnectedException;" };
  static const J2ObjcClassInfo _AndroidGovNistJavaxSipStackNioTlsMessageChannel = { "NioTlsMessageChannel", "android.gov.nist.javax.sip.stack", ptrTable, methods, fields, 7, 0x1, 22, 6, -1, 22, -1, -1, -1 };
  return &_AndroidGovNistJavaxSipStackNioTlsMessageChannel;
}

+ (void)initialize {
  if (self == [AndroidGovNistJavaxSipStackNioTlsMessageChannel class]) {
    AndroidGovNistJavaxSipStackNioTlsMessageChannel_super$_sendMessageWithByteArray_withJavaNetInetAddress_withInt_withBoolean_ = (void (*)(id, SEL, id, id, jint, jboolean))[AndroidGovNistJavaxSipStackNioTcpMessageChannel instanceMethodForSelector:@selector(sendMessageWithByteArray:withJavaNetInetAddress:withInt:withBoolean:)];
    AndroidGovNistJavaxSipStackNioTlsMessageChannel_super$_sendMessageWithByteArray_withBoolean_ = (void (*)(id, SEL, id, jboolean))[AndroidGovNistJavaxSipStackNioTcpMessageChannel instanceMethodForSelector:@selector(sendMessageWithByteArray:withBoolean:)];
    JreStrongAssign(&AndroidGovNistJavaxSipStackNioTlsMessageChannel_logger, OrgSlf4jLoggerFactory_getLoggerWithIOSClass_(AndroidGovNistJavaxSipStackNioTlsMessageChannel_class_()));
    J2OBJC_SET_INITIALIZED(AndroidGovNistJavaxSipStackNioTlsMessageChannel)
  }
}

@end

AndroidGovNistJavaxSipStackNioTcpMessageChannel *AndroidGovNistJavaxSipStackNioTlsMessageChannel_createWithAndroidGovNistJavaxSipStackNioTcpMessageProcessor_withJavaNioChannelsSocketChannel_(AndroidGovNistJavaxSipStackNioTcpMessageProcessor *nioTcpMessageProcessor, JavaNioChannelsSocketChannel *socketChannel) {
  AndroidGovNistJavaxSipStackNioTlsMessageChannel_initialize();
  AndroidGovNistJavaxSipStackNioTcpMessageChannel *retval = [((JavaUtilHashMap *) nil_chk(JreLoadStatic(AndroidGovNistJavaxSipStackNioTcpMessageChannel, channelMap))) getWithId:socketChannel];
  if (retval == nil) {
    retval = create_AndroidGovNistJavaxSipStackNioTlsMessageChannel_initWithAndroidGovNistJavaxSipStackNioTcpMessageProcessor_withJavaNioChannelsSocketChannel_(nioTcpMessageProcessor, socketChannel);
    [((JavaUtilHashMap *) nil_chk(JreLoadStatic(AndroidGovNistJavaxSipStackNioTcpMessageChannel, channelMap))) putWithId:socketChannel withId:retval];
  }
  return retval;
}

void AndroidGovNistJavaxSipStackNioTlsMessageChannel_initWithAndroidGovNistJavaxSipStackNioTcpMessageProcessor_withJavaNioChannelsSocketChannel_(AndroidGovNistJavaxSipStackNioTlsMessageChannel *self, AndroidGovNistJavaxSipStackNioTcpMessageProcessor *nioTcpMessageProcessor, JavaNioChannelsSocketChannel *socketChannel) {
  AndroidGovNistJavaxSipStackNioTcpMessageChannel_initWithAndroidGovNistJavaxSipStackNioTcpMessageProcessor_withJavaNioChannelsSocketChannel_(self, nioTcpMessageProcessor, socketChannel);
  self->handshakeCompleted_ = false;
  JreStrongAssign(&self->messageProcessor_, nioTcpMessageProcessor);
  JreStrongAssign(&self->myClientInputStream_, [((JavaNetSocket *) nil_chk([((JavaNioChannelsSocketChannel *) nil_chk(socketChannel)) socket])) getInputStream]);
  @try {
    [self init__WithBoolean:false];
    [self createBuffers];
  }
  @catch (JavaLangException *e) {
    @throw create_JavaIoIOException_initWithNSString_withNSException_(@"Can't do TLS init", e);
  }
}

AndroidGovNistJavaxSipStackNioTlsMessageChannel *new_AndroidGovNistJavaxSipStackNioTlsMessageChannel_initWithAndroidGovNistJavaxSipStackNioTcpMessageProcessor_withJavaNioChannelsSocketChannel_(AndroidGovNistJavaxSipStackNioTcpMessageProcessor *nioTcpMessageProcessor, JavaNioChannelsSocketChannel *socketChannel) {
  J2OBJC_NEW_IMPL(AndroidGovNistJavaxSipStackNioTlsMessageChannel, initWithAndroidGovNistJavaxSipStackNioTcpMessageProcessor_withJavaNioChannelsSocketChannel_, nioTcpMessageProcessor, socketChannel)
}

AndroidGovNistJavaxSipStackNioTlsMessageChannel *create_AndroidGovNistJavaxSipStackNioTlsMessageChannel_initWithAndroidGovNistJavaxSipStackNioTcpMessageProcessor_withJavaNioChannelsSocketChannel_(AndroidGovNistJavaxSipStackNioTcpMessageProcessor *nioTcpMessageProcessor, JavaNioChannelsSocketChannel *socketChannel) {
  J2OBJC_CREATE_IMPL(AndroidGovNistJavaxSipStackNioTlsMessageChannel, initWithAndroidGovNistJavaxSipStackNioTcpMessageProcessor_withJavaNioChannelsSocketChannel_, nioTcpMessageProcessor, socketChannel)
}

void AndroidGovNistJavaxSipStackNioTlsMessageChannel_initWithJavaNetInetAddress_withInt_withAndroidGovNistJavaxSipStackSIPTransactionStack_withAndroidGovNistJavaxSipStackNioTcpMessageProcessor_(AndroidGovNistJavaxSipStackNioTlsMessageChannel *self, JavaNetInetAddress *inetAddress, jint port, AndroidGovNistJavaxSipStackSIPTransactionStack *sipStack, AndroidGovNistJavaxSipStackNioTcpMessageProcessor *nioTcpMessageProcessor) {
  AndroidGovNistJavaxSipStackNioTcpMessageChannel_initWithJavaNetInetAddress_withInt_withAndroidGovNistJavaxSipStackSIPTransactionStack_withAndroidGovNistJavaxSipStackNioTcpMessageProcessor_(self, inetAddress, port, sipStack, nioTcpMessageProcessor);
  self->handshakeCompleted_ = false;
  @try {
    [self init__WithBoolean:true];
    [self createBuffers];
  }
  @catch (JavaLangException *e) {
    @throw create_JavaIoIOException_initWithNSString_withNSException_(@"Can't init the TLS channel", e);
  }
}

AndroidGovNistJavaxSipStackNioTlsMessageChannel *new_AndroidGovNistJavaxSipStackNioTlsMessageChannel_initWithJavaNetInetAddress_withInt_withAndroidGovNistJavaxSipStackSIPTransactionStack_withAndroidGovNistJavaxSipStackNioTcpMessageProcessor_(JavaNetInetAddress *inetAddress, jint port, AndroidGovNistJavaxSipStackSIPTransactionStack *sipStack, AndroidGovNistJavaxSipStackNioTcpMessageProcessor *nioTcpMessageProcessor) {
  J2OBJC_NEW_IMPL(AndroidGovNistJavaxSipStackNioTlsMessageChannel, initWithJavaNetInetAddress_withInt_withAndroidGovNistJavaxSipStackSIPTransactionStack_withAndroidGovNistJavaxSipStackNioTcpMessageProcessor_, inetAddress, port, sipStack, nioTcpMessageProcessor)
}

AndroidGovNistJavaxSipStackNioTlsMessageChannel *create_AndroidGovNistJavaxSipStackNioTlsMessageChannel_initWithJavaNetInetAddress_withInt_withAndroidGovNistJavaxSipStackSIPTransactionStack_withAndroidGovNistJavaxSipStackNioTcpMessageProcessor_(JavaNetInetAddress *inetAddress, jint port, AndroidGovNistJavaxSipStackSIPTransactionStack *sipStack, AndroidGovNistJavaxSipStackNioTcpMessageProcessor *nioTcpMessageProcessor) {
  J2OBJC_CREATE_IMPL(AndroidGovNistJavaxSipStackNioTlsMessageChannel, initWithJavaNetInetAddress_withInt_withAndroidGovNistJavaxSipStackSIPTransactionStack_withAndroidGovNistJavaxSipStackNioTcpMessageProcessor_, inetAddress, port, sipStack, nioTcpMessageProcessor)
}

void AndroidGovNistJavaxSipStackNioTlsMessageChannel_checkSocketState(AndroidGovNistJavaxSipStackNioTlsMessageChannel *self) {
  if (self->socketChannel_ != nil && (![self->socketChannel_ isConnected] || ![((JavaNioChannelsSocketChannel *) nil_chk(self->socketChannel_)) isOpen])) {
    [((id<OrgSlf4jLogger>) nil_chk(AndroidGovNistJavaxSipStackNioTlsMessageChannel_logger)) debugWithNSString:JreStrcat("$@", @"Need to reset SSL engine for socket ", self->socketChannel_)];
    @try {
      [self init__WithBoolean:[((JavaxNetSslSSLEngine *) nil_chk(((AndroidGovNistJavaxSipStackSSLStateMachine *) nil_chk(self->sslStateMachine_))->sslEngine_)) getUseClientMode]];
    }
    @catch (JavaLangException *ex) {
      [((id<OrgSlf4jLogger>) nil_chk(AndroidGovNistJavaxSipStackNioTlsMessageChannel_logger)) errorWithNSString:@"Cannot reset SSL engine" withNSException:ex];
      @throw create_JavaIoIOException_initWithNSException_(ex);
    }
  }
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(AndroidGovNistJavaxSipStackNioTlsMessageChannel)

@implementation AndroidGovNistJavaxSipStackNioTlsMessageChannel_SSLReconnectedException

J2OBJC_IGNORE_DESIGNATED_BEGIN
- (instancetype)init {
  AndroidGovNistJavaxSipStackNioTlsMessageChannel_SSLReconnectedException_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(init);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "serialVersionUID", "J", .constantValue.asLong = AndroidGovNistJavaxSipStackNioTlsMessageChannel_SSLReconnectedException_serialVersionUID, 0x1a, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LAndroidGovNistJavaxSipStackNioTlsMessageChannel;" };
  static const J2ObjcClassInfo _AndroidGovNistJavaxSipStackNioTlsMessageChannel_SSLReconnectedException = { "SSLReconnectedException", "android.gov.nist.javax.sip.stack", ptrTable, methods, fields, 7, 0x9, 1, 1, 0, -1, -1, -1, -1 };
  return &_AndroidGovNistJavaxSipStackNioTlsMessageChannel_SSLReconnectedException;
}

@end

void AndroidGovNistJavaxSipStackNioTlsMessageChannel_SSLReconnectedException_init(AndroidGovNistJavaxSipStackNioTlsMessageChannel_SSLReconnectedException *self) {
  JavaIoIOException_init(self);
}

AndroidGovNistJavaxSipStackNioTlsMessageChannel_SSLReconnectedException *new_AndroidGovNistJavaxSipStackNioTlsMessageChannel_SSLReconnectedException_init() {
  J2OBJC_NEW_IMPL(AndroidGovNistJavaxSipStackNioTlsMessageChannel_SSLReconnectedException, init)
}

AndroidGovNistJavaxSipStackNioTlsMessageChannel_SSLReconnectedException *create_AndroidGovNistJavaxSipStackNioTlsMessageChannel_SSLReconnectedException_init() {
  J2OBJC_CREATE_IMPL(AndroidGovNistJavaxSipStackNioTlsMessageChannel_SSLReconnectedException, init)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(AndroidGovNistJavaxSipStackNioTlsMessageChannel_SSLReconnectedException)

@implementation AndroidGovNistJavaxSipStackNioTlsMessageChannel_1

- (instancetype)initWithAndroidGovNistJavaxSipStackNioTlsMessageChannel:(AndroidGovNistJavaxSipStackNioTlsMessageChannel *)outer$
                                                            withBoolean:(jboolean)capture$0 {
  AndroidGovNistJavaxSipStackNioTlsMessageChannel_1_initWithAndroidGovNistJavaxSipStackNioTlsMessageChannel_withBoolean_(self, outer$, capture$0);
  return self;
}

- (void)doSendWithByteArray:(IOSByteArray *)bytes {
  AndroidGovNistJavaxSipStackNioTlsMessageChannel_super$_sendMessageWithByteArray_withBoolean_(this$0_, @selector(sendMessageWithByteArray:withBoolean:), bytes, val$isClient_);
}

- (void)dealloc {
  RELEASE_(this$0_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 0, 1, 2, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(initWithAndroidGovNistJavaxSipStackNioTlsMessageChannel:withBoolean:);
  methods[1].selector = @selector(doSendWithByteArray:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "this$0_", "LAndroidGovNistJavaxSipStackNioTlsMessageChannel;", .constantValue.asLong = 0, 0x1012, -1, -1, -1, -1 },
    { "val$isClient_", "Z", .constantValue.asLong = 0, 0x1012, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "doSend", "[B", "LJavaIoIOException;", "LAndroidGovNistJavaxSipStackNioTlsMessageChannel;", "sendMessageWithByteArray:withBoolean:" };
  static const J2ObjcClassInfo _AndroidGovNistJavaxSipStackNioTlsMessageChannel_1 = { "", "android.gov.nist.javax.sip.stack", ptrTable, methods, fields, 7, 0x8008, 2, 2, 3, -1, 4, -1, -1 };
  return &_AndroidGovNistJavaxSipStackNioTlsMessageChannel_1;
}

@end

void AndroidGovNistJavaxSipStackNioTlsMessageChannel_1_initWithAndroidGovNistJavaxSipStackNioTlsMessageChannel_withBoolean_(AndroidGovNistJavaxSipStackNioTlsMessageChannel_1 *self, AndroidGovNistJavaxSipStackNioTlsMessageChannel *outer$, jboolean capture$0) {
  JreStrongAssign(&self->this$0_, outer$);
  self->val$isClient_ = capture$0;
  NSObject_init(self);
}

AndroidGovNistJavaxSipStackNioTlsMessageChannel_1 *new_AndroidGovNistJavaxSipStackNioTlsMessageChannel_1_initWithAndroidGovNistJavaxSipStackNioTlsMessageChannel_withBoolean_(AndroidGovNistJavaxSipStackNioTlsMessageChannel *outer$, jboolean capture$0) {
  J2OBJC_NEW_IMPL(AndroidGovNistJavaxSipStackNioTlsMessageChannel_1, initWithAndroidGovNistJavaxSipStackNioTlsMessageChannel_withBoolean_, outer$, capture$0)
}

AndroidGovNistJavaxSipStackNioTlsMessageChannel_1 *create_AndroidGovNistJavaxSipStackNioTlsMessageChannel_1_initWithAndroidGovNistJavaxSipStackNioTlsMessageChannel_withBoolean_(AndroidGovNistJavaxSipStackNioTlsMessageChannel *outer$, jboolean capture$0) {
  J2OBJC_CREATE_IMPL(AndroidGovNistJavaxSipStackNioTlsMessageChannel_1, initWithAndroidGovNistJavaxSipStackNioTlsMessageChannel_withBoolean_, outer$, capture$0)
}

@implementation AndroidGovNistJavaxSipStackNioTlsMessageChannel_2

- (instancetype)initWithAndroidGovNistJavaxSipStackNioTlsMessageChannel:(AndroidGovNistJavaxSipStackNioTlsMessageChannel *)outer$
                                                 withJavaNetInetAddress:(JavaNetInetAddress *)capture$0
                                                                withInt:(jint)capture$1
                                                            withBoolean:(jboolean)capture$2 {
  AndroidGovNistJavaxSipStackNioTlsMessageChannel_2_initWithAndroidGovNistJavaxSipStackNioTlsMessageChannel_withJavaNetInetAddress_withInt_withBoolean_(self, outer$, capture$0, capture$1, capture$2);
  return self;
}

- (void)doSendWithByteArray:(IOSByteArray *)bytes {
  AndroidGovNistJavaxSipStackNioTlsMessageChannel_super$_sendMessageWithByteArray_withJavaNetInetAddress_withInt_withBoolean_(this$0_, @selector(sendMessageWithByteArray:withJavaNetInetAddress:withInt:withBoolean:), bytes, val$receiverAddress_, val$receiverPort_, val$retry_);
}

- (void)dealloc {
  RELEASE_(this$0_);
  RELEASE_(val$receiverAddress_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 0, 1, 2, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(initWithAndroidGovNistJavaxSipStackNioTlsMessageChannel:withJavaNetInetAddress:withInt:withBoolean:);
  methods[1].selector = @selector(doSendWithByteArray:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "this$0_", "LAndroidGovNistJavaxSipStackNioTlsMessageChannel;", .constantValue.asLong = 0, 0x1012, -1, -1, -1, -1 },
    { "val$receiverAddress_", "LJavaNetInetAddress;", .constantValue.asLong = 0, 0x1012, -1, -1, -1, -1 },
    { "val$receiverPort_", "I", .constantValue.asLong = 0, 0x1012, -1, -1, -1, -1 },
    { "val$retry_", "Z", .constantValue.asLong = 0, 0x1012, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "doSend", "[B", "LJavaIoIOException;", "LAndroidGovNistJavaxSipStackNioTlsMessageChannel;", "sendMessageWithByteArray:withJavaNetInetAddress:withInt:withBoolean:" };
  static const J2ObjcClassInfo _AndroidGovNistJavaxSipStackNioTlsMessageChannel_2 = { "", "android.gov.nist.javax.sip.stack", ptrTable, methods, fields, 7, 0x8008, 2, 4, 3, -1, 4, -1, -1 };
  return &_AndroidGovNistJavaxSipStackNioTlsMessageChannel_2;
}

@end

void AndroidGovNistJavaxSipStackNioTlsMessageChannel_2_initWithAndroidGovNistJavaxSipStackNioTlsMessageChannel_withJavaNetInetAddress_withInt_withBoolean_(AndroidGovNistJavaxSipStackNioTlsMessageChannel_2 *self, AndroidGovNistJavaxSipStackNioTlsMessageChannel *outer$, JavaNetInetAddress *capture$0, jint capture$1, jboolean capture$2) {
  JreStrongAssign(&self->this$0_, outer$);
  JreStrongAssign(&self->val$receiverAddress_, capture$0);
  self->val$receiverPort_ = capture$1;
  self->val$retry_ = capture$2;
  NSObject_init(self);
}

AndroidGovNistJavaxSipStackNioTlsMessageChannel_2 *new_AndroidGovNistJavaxSipStackNioTlsMessageChannel_2_initWithAndroidGovNistJavaxSipStackNioTlsMessageChannel_withJavaNetInetAddress_withInt_withBoolean_(AndroidGovNistJavaxSipStackNioTlsMessageChannel *outer$, JavaNetInetAddress *capture$0, jint capture$1, jboolean capture$2) {
  J2OBJC_NEW_IMPL(AndroidGovNistJavaxSipStackNioTlsMessageChannel_2, initWithAndroidGovNistJavaxSipStackNioTlsMessageChannel_withJavaNetInetAddress_withInt_withBoolean_, outer$, capture$0, capture$1, capture$2)
}

AndroidGovNistJavaxSipStackNioTlsMessageChannel_2 *create_AndroidGovNistJavaxSipStackNioTlsMessageChannel_2_initWithAndroidGovNistJavaxSipStackNioTlsMessageChannel_withJavaNetInetAddress_withInt_withBoolean_(AndroidGovNistJavaxSipStackNioTlsMessageChannel *outer$, JavaNetInetAddress *capture$0, jint capture$1, jboolean capture$2) {
  J2OBJC_CREATE_IMPL(AndroidGovNistJavaxSipStackNioTlsMessageChannel_2, initWithAndroidGovNistJavaxSipStackNioTlsMessageChannel_withJavaNetInetAddress_withInt_withBoolean_, outer$, capture$0, capture$1, capture$2)
}
