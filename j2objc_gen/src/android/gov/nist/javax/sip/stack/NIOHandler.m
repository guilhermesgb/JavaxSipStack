//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: ./src/android/gov/nist/javax/sip/stack/NIOHandler.java
//

#include "IOSClass.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "android/gov/nist/javax/sip/SipStackImpl.h"
#include "android/gov/nist/javax/sip/stack/ConnectionOrientedMessageChannel.h"
#include "android/gov/nist/javax/sip/stack/HandshakeCompletedListenerImpl.h"
#include "android/gov/nist/javax/sip/stack/KeyedSemaphore.h"
#include "android/gov/nist/javax/sip/stack/NIOHandler.h"
#include "android/gov/nist/javax/sip/stack/NioTcpMessageChannel.h"
#include "android/gov/nist/javax/sip/stack/NioTcpMessageProcessor.h"
#include "android/gov/nist/javax/sip/stack/NioTlsMessageChannel.h"
#include "android/gov/nist/javax/sip/stack/SIPTransactionStack.h"
#include "java/io/IOException.h"
#include "java/lang/Exception.h"
#include "java/lang/System.h"
#include "java/net/InetAddress.h"
#include "java/net/InetSocketAddress.h"
#include "java/net/SocketAddress.h"
#include "java/net/SocketException.h"
#include "java/nio/channels/SocketChannel.h"
#include "java/util/Enumeration.h"
#include "java/util/HashMap.h"
#include "java/util/Iterator.h"
#include "java/util/LinkedList.h"
#include "java/util/Map.h"
#include "java/util/Set.h"
#include "java/util/concurrent/ConcurrentHashMap.h"
#include "java/util/concurrent/atomic/AtomicBoolean.h"
#include "org/slf4j/Logger.h"
#include "org/slf4j/LoggerFactory.h"

@interface AndroidGovNistJavaxSipStackNIOHandler () {
 @public
  AndroidGovNistJavaxSipSipStackImpl *sipStack_;
  AndroidGovNistJavaxSipStackNioTcpMessageProcessor *messageProcessor_;
  JavaUtilConcurrentAtomicAtomicBoolean *stopped_;
  JavaUtilConcurrentConcurrentHashMap *socketTable_;
}

- (void)writeChunksWithJavaNioChannelsSocketChannel:(JavaNioChannelsSocketChannel *)channel
                                      withByteArray:(IOSByteArray *)bytes
                                            withInt:(jint)length;

@end

J2OBJC_FIELD_SETTER(AndroidGovNistJavaxSipStackNIOHandler, sipStack_, AndroidGovNistJavaxSipSipStackImpl *)
J2OBJC_FIELD_SETTER(AndroidGovNistJavaxSipStackNIOHandler, messageProcessor_, AndroidGovNistJavaxSipStackNioTcpMessageProcessor *)
J2OBJC_FIELD_SETTER(AndroidGovNistJavaxSipStackNIOHandler, stopped_, JavaUtilConcurrentAtomicAtomicBoolean *)
J2OBJC_FIELD_SETTER(AndroidGovNistJavaxSipStackNIOHandler, socketTable_, JavaUtilConcurrentConcurrentHashMap *)

inline id<OrgSlf4jLogger> AndroidGovNistJavaxSipStackNIOHandler_get_logger();
inline id<OrgSlf4jLogger> AndroidGovNistJavaxSipStackNIOHandler_set_logger(id<OrgSlf4jLogger> value);
static id<OrgSlf4jLogger> AndroidGovNistJavaxSipStackNIOHandler_logger;
J2OBJC_STATIC_FIELD_OBJ(AndroidGovNistJavaxSipStackNIOHandler, logger, id<OrgSlf4jLogger>)

__attribute__((unused)) static void AndroidGovNistJavaxSipStackNIOHandler_writeChunksWithJavaNioChannelsSocketChannel_withByteArray_withInt_(AndroidGovNistJavaxSipStackNIOHandler *self, JavaNioChannelsSocketChannel *channel, IOSByteArray *bytes, jint length);

J2OBJC_INITIALIZED_DEFN(AndroidGovNistJavaxSipStackNIOHandler)

@implementation AndroidGovNistJavaxSipStackNIOHandler

+ (NSString *)makeKeyWithJavaNetInetAddress:(JavaNetInetAddress *)addr
                                    withInt:(jint)port {
  return AndroidGovNistJavaxSipStackNIOHandler_makeKeyWithJavaNetInetAddress_withInt_(addr, port);
}

+ (NSString *)makeKeyWithNSString:(NSString *)addr
                          withInt:(jint)port {
  return AndroidGovNistJavaxSipStackNIOHandler_makeKeyWithNSString_withInt_(addr, port);
}

- (instancetype)initWithAndroidGovNistJavaxSipStackSIPTransactionStack:(AndroidGovNistJavaxSipStackSIPTransactionStack *)sipStack
                 withAndroidGovNistJavaxSipStackNioTcpMessageProcessor:(AndroidGovNistJavaxSipStackNioTcpMessageProcessor *)messageProcessor {
  AndroidGovNistJavaxSipStackNIOHandler_initWithAndroidGovNistJavaxSipStackSIPTransactionStack_withAndroidGovNistJavaxSipStackNioTcpMessageProcessor_(self, sipStack, messageProcessor);
  return self;
}

- (void)putSocketWithNSString:(NSString *)key
withJavaNioChannelsSocketChannel:(JavaNioChannelsSocketChannel *)sock {
  if ([((JavaUtilConcurrentAtomicAtomicBoolean *) nil_chk(stopped_)) get]) return;
  @synchronized(socketTable_) {
    [((id<OrgSlf4jLogger>) nil_chk(AndroidGovNistJavaxSipStackNIOHandler_logger)) debugWithNSString:JreStrcat("$$", @"adding socket for key ", key)];
    [((JavaUtilConcurrentConcurrentHashMap *) nil_chk(socketTable_)) putWithId:key withId:sock];
  }
}

- (JavaNioChannelsSocketChannel *)getSocketWithNSString:(NSString *)key {
  return [((JavaUtilConcurrentConcurrentHashMap *) nil_chk(socketTable_)) getWithId:key];
}

- (void)removeSocketWithNSString:(NSString *)key {
  @synchronized(socketTable_) {
    [((JavaUtilConcurrentConcurrentHashMap *) nil_chk(socketTable_)) removeWithId:key];
    [((AndroidGovNistJavaxSipStackKeyedSemaphore *) nil_chk(keyedSemaphore_)) removeWithNSString:key];
    [((id<OrgSlf4jLogger>) nil_chk(AndroidGovNistJavaxSipStackNIOHandler_logger)) debugWithNSString:JreStrcat("$$", @"removed Socket and Semaphore for key ", key)];
  }
}

- (void)removeSocketWithJavaNioChannelsSocketChannel:(JavaNioChannelsSocketChannel *)channel {
  [((id<OrgSlf4jLogger>) nil_chk(AndroidGovNistJavaxSipStackNIOHandler_logger)) debugWithNSString:JreStrcat("$@$@", @"Trying to remove cached socketChannel without key", self, @" socketChannel = ", channel)];
  JavaUtilLinkedList *keys = create_JavaUtilLinkedList_init();
  @synchronized(socketTable_) {
    id<JavaUtilSet> e = [((JavaUtilConcurrentConcurrentHashMap *) nil_chk(socketTable_)) entrySet];
    for (id<JavaUtilMap_Entry> __strong entry_ in nil_chk(e)) {
      JavaNioChannelsSocketChannel *sc = [((id<JavaUtilMap_Entry>) nil_chk(entry_)) getValue];
      if ([((JavaNioChannelsSocketChannel *) nil_chk(sc)) isEqual:channel]) {
        [keys addWithId:[entry_ getKey]];
      }
    }
    for (NSString * __strong key in keys) {
      [((id<OrgSlf4jLogger>) nil_chk(AndroidGovNistJavaxSipStackNIOHandler_logger)) debugWithNSString:JreStrcat("$@$@$$", @"Removing cached socketChannel without key", self, @" socketChannel = ", channel, @" key = ", key)];
      [self removeSocketWithNSString:key];
    }
  }
}

- (void)writeChunksWithJavaNioChannelsSocketChannel:(JavaNioChannelsSocketChannel *)channel
                                      withByteArray:(IOSByteArray *)bytes
                                            withInt:(jint)length {
  AndroidGovNistJavaxSipStackNIOHandler_writeChunksWithJavaNioChannelsSocketChannel_withByteArray_withInt_(self, channel, bytes, length);
}

- (JavaNioChannelsSocketChannel *)sendBytesWithJavaNetInetAddress:(JavaNetInetAddress *)senderAddress
                                           withJavaNetInetAddress:(JavaNetInetAddress *)receiverAddress
                                                          withInt:(jint)contactPort
                                                     withNSString:(NSString *)transport
                                                    withByteArray:(IOSByteArray *)bytes
                                                      withBoolean:(jboolean)isClient
              withAndroidGovNistJavaxSipStackNioTcpMessageChannel:(AndroidGovNistJavaxSipStackNioTcpMessageChannel *)messageChannel {
  if ([((JavaUtilConcurrentAtomicAtomicBoolean *) nil_chk(stopped_)) get]) return nil;
  jint retry_count = 0;
  jint max_retry = isClient ? 2 : 1;
  jint length = ((IOSByteArray *) nil_chk(bytes))->size_;
  [((id<OrgSlf4jLogger>) nil_chk(AndroidGovNistJavaxSipStackNIOHandler_logger)) debugWithNSString:JreStrcat("$$$$$I$I$Z", @"sendBytes ", transport, @" inAddr ", [((JavaNetInetAddress *) nil_chk(receiverAddress)) getHostAddress], @" port = ", contactPort, @" length = ", length, @" isClient ", isClient)];
  NSString *key = AndroidGovNistJavaxSipStackNIOHandler_makeKeyWithJavaNetInetAddress_withInt_(receiverAddress, contactPort);
  JavaNioChannelsSocketChannel *clientSock = nil;
  [((AndroidGovNistJavaxSipStackKeyedSemaphore *) nil_chk(keyedSemaphore_)) enterIOCriticalSectionWithNSString:key];
  jboolean newSocket = false;
  @try {
    clientSock = [self getSocketWithNSString:key];
    while (retry_count < max_retry) {
      if (clientSock != nil && (![clientSock isConnected] || ![clientSock isOpen])) {
        [self removeSocketWithNSString:key];
        clientSock = nil;
        newSocket = true;
      }
      if (clientSock == nil) {
        [((id<OrgSlf4jLogger>) nil_chk(AndroidGovNistJavaxSipStackNIOHandler_logger)) debugWithNSString:JreStrcat("$@", @"inaddr = ", receiverAddress)];
        [((id<OrgSlf4jLogger>) nil_chk(AndroidGovNistJavaxSipStackNIOHandler_logger)) debugWithNSString:JreStrcat("$I", @"port = ", contactPort)];
        @try {
          clientSock = [((AndroidGovNistJavaxSipStackNioTcpMessageProcessor *) nil_chk(messageProcessor_)) blockingConnectWithJavaNetInetSocketAddress:create_JavaNetInetSocketAddress_initWithJavaNetInetAddress_withInt_(receiverAddress, contactPort) withJavaNetInetAddress:senderAddress withInt:10000];
          if ([messageChannel isKindOfClass:[AndroidGovNistJavaxSipStackNioTlsMessageChannel class]]) {
            AndroidGovNistJavaxSipStackHandshakeCompletedListenerImpl *listner = create_AndroidGovNistJavaxSipStackHandshakeCompletedListenerImpl_initWithAndroidGovNistJavaxSipStackNioTlsMessageChannel_withJavaNioChannelsSocketChannel_((AndroidGovNistJavaxSipStackNioTlsMessageChannel *) cast_chk(messageChannel, [AndroidGovNistJavaxSipStackNioTlsMessageChannel class]), clientSock);
            [((AndroidGovNistJavaxSipStackNioTlsMessageChannel *) nil_chk(((AndroidGovNistJavaxSipStackNioTlsMessageChannel *) cast_chk(messageChannel, [AndroidGovNistJavaxSipStackNioTlsMessageChannel class])))) setHandshakeCompletedListenerWithJavaxNetSslHandshakeCompletedListener:listner];
          }
          newSocket = true;
        }
        @catch (JavaNetSocketException *e) {
          [((id<OrgSlf4jLogger>) nil_chk(AndroidGovNistJavaxSipStackNIOHandler_logger)) errorWithNSString:JreStrcat("$@CIC@$$", @"Problem connecting ", receiverAddress, ' ', contactPort, ' ', senderAddress, @" for message ", ([((AndroidGovNistJavaxSipStackNioTcpMessageChannel *) nil_chk(messageChannel)) isSecure] ? @"<<<ENCRYPTED MESSAGE>>>" : [NSString java_stringWithBytes:bytes charsetName:@"UTF-8"]))];
          [self removeSocketWithNSString:key];
          @throw create_JavaNetSocketException_initWithNSString_(JreStrcat("@C$C@$@CIC@$$", [((JavaNetSocketException *) nil_chk(e)) java_getClass], ' ', [e getMessage], ' ', [e getCause], @" Problem connecting ", receiverAddress, ' ', contactPort, ' ', senderAddress, @" for message ", [NSString java_stringWithBytes:bytes charsetName:@"UTF-8"]));
        }
        [self putSocketWithNSString:key withJavaNioChannelsSocketChannel:clientSock];
        break;
      }
      else {
        break;
      }
    }
  }
  @catch (JavaIoIOException *ex) {
    [((id<OrgSlf4jLogger>) nil_chk(AndroidGovNistJavaxSipStackNIOHandler_logger)) errorWithNSString:JreStrcat("$$$$$I$$$I$I$Z", @"Problem sending: sendBytes ", transport, @" inAddr ", [receiverAddress getHostAddress], @" port = ", contactPort, @" remoteHost ", [((AndroidGovNistJavaxSipStackNioTcpMessageChannel *) nil_chk(messageChannel)) getPeerAddress], @" remotePort ", [messageChannel getPeerPort], @" peerPacketPort ", [messageChannel getPeerPacketSourcePort], @" isClient ", isClient)];
    [self removeSocketWithNSString:key];
    if (!isClient) {
      receiverAddress = JavaNetInetAddress_getByNameWithNSString_(messageChannel->peerAddressAdvertisedInHeaders_);
      contactPort = messageChannel->peerPortAdvertisedInHeaders_;
      if (contactPort <= 0) contactPort = 5060;
      key = AndroidGovNistJavaxSipStackNIOHandler_makeKeyWithJavaNetInetAddress_withInt_(receiverAddress, contactPort);
      clientSock = [self getSocketWithNSString:key];
      if (clientSock == nil || ![clientSock isConnected] || ![clientSock isOpen]) {
        [((id<OrgSlf4jLogger>) nil_chk(AndroidGovNistJavaxSipStackNIOHandler_logger)) debugWithNSString:JreStrcat("$@$I", @"inaddr = ", receiverAddress, @" port = ", contactPort)];
        clientSock = [((AndroidGovNistJavaxSipStackNioTcpMessageProcessor *) nil_chk(messageProcessor_)) blockingConnectWithJavaNetInetSocketAddress:create_JavaNetInetSocketAddress_initWithJavaNetInetAddress_withInt_(receiverAddress, contactPort) withJavaNetInetAddress:senderAddress withInt:10000];
        newSocket = true;
        messageChannel->peerPort_ = contactPort;
        [self putSocketWithNSString:key withJavaNioChannelsSocketChannel:clientSock];
      }
      [((id<OrgSlf4jLogger>) nil_chk(AndroidGovNistJavaxSipStackNIOHandler_logger)) debugWithNSString:JreStrcat("$$", @"sending to ", key)];
    }
    else {
      [((id<OrgSlf4jLogger>) nil_chk(AndroidGovNistJavaxSipStackNIOHandler_logger)) errorWithNSString:@"IOException occured at " withNSException:ex];
      @throw ex;
    }
    return clientSock;
  }
  @finally {
    @try {
      if (clientSock != nil) {
        if (newSocket && [messageChannel isKindOfClass:[AndroidGovNistJavaxSipStackNioTlsMessageChannel class]]) {
        }
        else {
          AndroidGovNistJavaxSipStackNIOHandler_writeChunksWithJavaNioChannelsSocketChannel_withByteArray_withInt_(self, clientSock, bytes, length);
        }
      }
    }
    @finally {
      [((AndroidGovNistJavaxSipStackKeyedSemaphore *) nil_chk(keyedSemaphore_)) leaveIOCriticalSectionWithNSString:key];
    }
  }
  if (clientSock == nil) {
    [((id<OrgSlf4jLogger>) nil_chk(AndroidGovNistJavaxSipStackNIOHandler_logger)) errorWithNSString:[((JavaUtilConcurrentConcurrentHashMap *) nil_chk(self->socketTable_)) description]];
    [((id<OrgSlf4jLogger>) nil_chk(AndroidGovNistJavaxSipStackNIOHandler_logger)) errorWithNSString:JreStrcat("$@CI", @"Could not connect to ", receiverAddress, ':', contactPort)];
    @throw create_JavaIoIOException_initWithNSString_(JreStrcat("$@CI", @"Could not connect to ", receiverAddress, ':', contactPort));
  }
  else {
    return clientSock;
  }
}

- (void)closeAll {
  [((id<OrgSlf4jLogger>) nil_chk(AndroidGovNistJavaxSipStackNIOHandler_logger)) debugWithNSString:JreStrcat("$I$", @"Closing ", [((JavaUtilConcurrentConcurrentHashMap *) nil_chk(socketTable_)) size], @" sockets from IOHandler")];
  for (id<JavaUtilEnumeration> values = [socketTable_ elements]; [((id<JavaUtilEnumeration>) nil_chk(values)) hasMoreElements]; ) {
    JavaNioChannelsSocketChannel *s = [values nextElement];
    @try {
      [((JavaNioChannelsSocketChannel *) nil_chk(s)) close];
    }
    @catch (JavaIoIOException *ex) {
    }
  }
}

- (void)stop {
  [((JavaUtilConcurrentAtomicAtomicBoolean *) nil_chk(stopped_)) setWithBoolean:true];
  @try {
    [((id<OrgSlf4jLogger>) nil_chk(AndroidGovNistJavaxSipStackNIOHandler_logger)) debugWithNSString:JreStrcat("$@", @"keys to check for inactivity removal ", [((JavaUtilHashMap *) nil_chk(JreLoadStatic(AndroidGovNistJavaxSipStackNioTcpMessageChannel, channelMap))) keySet])];
    [((id<OrgSlf4jLogger>) nil_chk(AndroidGovNistJavaxSipStackNIOHandler_logger)) debugWithNSString:JreStrcat("$@", @"existing socket in NIOHandler ", [((JavaUtilConcurrentConcurrentHashMap *) nil_chk(socketTable_)) keySet])];
    id<JavaUtilIterator> entriesIterator = [((id<JavaUtilSet>) nil_chk([((JavaUtilHashMap *) nil_chk(JreLoadStatic(AndroidGovNistJavaxSipStackNioTcpMessageChannel, channelMap))) entrySet])) iterator];
    while ([((id<JavaUtilIterator>) nil_chk(entriesIterator)) hasNext]) {
      id<JavaUtilMap_Entry> entry_ = [entriesIterator next];
      JavaNioChannelsSocketChannel *socketChannel = [((id<JavaUtilMap_Entry>) nil_chk(entry_)) getKey];
      AndroidGovNistJavaxSipStackNioTcpMessageChannel *messageChannel = [entry_ getValue];
      [((id<OrgSlf4jLogger>) nil_chk(AndroidGovNistJavaxSipStackNIOHandler_logger)) debugWithNSString:JreStrcat("$$$@", @"stop() : Removing socket ", ((AndroidGovNistJavaxSipStackConnectionOrientedMessageChannel *) nil_chk(messageChannel))->key_, @" socketChannel = ", socketChannel)];
      [messageChannel close];
      [((JavaUtilHashMap *) nil_chk(JreLoadStatic(AndroidGovNistJavaxSipStackNioTcpMessageChannel, channelMap))) removeWithId:socketChannel];
      entriesIterator = [((id<JavaUtilSet>) nil_chk([((JavaUtilHashMap *) nil_chk(JreLoadStatic(AndroidGovNistJavaxSipStackNioTcpMessageChannel, channelMap))) entrySet])) iterator];
    }
  }
  @catch (JavaLangException *e) {
  }
}

- (JavaNioChannelsSocketChannel *)createOrReuseSocketWithJavaNetInetAddress:(JavaNetInetAddress *)inetAddress
                                                                    withInt:(jint)port {
  if ([((JavaUtilConcurrentAtomicAtomicBoolean *) nil_chk(stopped_)) get]) return nil;
  NSString *key = AndroidGovNistJavaxSipStackNIOHandler_makeKeyWithJavaNetInetAddress_withInt_(inetAddress, port);
  JavaNioChannelsSocketChannel *channel = nil;
  [((AndroidGovNistJavaxSipStackKeyedSemaphore *) nil_chk(keyedSemaphore_)) enterIOCriticalSectionWithNSString:key];
  @try {
    channel = [self getSocketWithNSString:key];
    if (channel != nil && (![channel isConnected] || ![channel isOpen])) {
      [((id<OrgSlf4jLogger>) nil_chk(AndroidGovNistJavaxSipStackNIOHandler_logger)) debugWithNSString:JreStrcat("$@", @"Channel disconnected ", channel)];
      channel = nil;
    }
    if (channel == nil) {
      @try {
        JavaNetSocketAddress *sockAddr = create_JavaNetInetSocketAddress_initWithJavaNetInetAddress_withInt_(inetAddress, port);
        channel = [((AndroidGovNistJavaxSipStackNioTcpMessageProcessor *) nil_chk(messageProcessor_)) blockingConnectWithJavaNetInetSocketAddress:(JavaNetInetSocketAddress *) cast_chk(sockAddr, [JavaNetInetSocketAddress class]) withJavaNetInetAddress:[self->messageProcessor_ getIpAddress] withInt:10000];
        [((id<OrgSlf4jLogger>) nil_chk(AndroidGovNistJavaxSipStackNIOHandler_logger)) debugWithNSString:JreStrcat("$@$@CI", @"create channel = ", channel, @"  ", inetAddress, ' ', port)];
        if (channel != nil && [channel isConnected]) {
          [self putSocketWithNSString:AndroidGovNistJavaxSipStackNIOHandler_makeKeyWithJavaNetInetAddress_withInt_(inetAddress, port) withJavaNioChannelsSocketChannel:channel];
          [((id<OrgSlf4jLogger>) nil_chk(AndroidGovNistJavaxSipStackNIOHandler_logger)) debugWithNSString:JreStrcat("$@", @"channel cached channel = ", channel)];
        }
      }
      @catch (JavaNetSocketException *e) {
        [((id<OrgSlf4jLogger>) nil_chk(AndroidGovNistJavaxSipStackNIOHandler_logger)) errorWithNSString:JreStrcat("$@CIC@", @"Problem connecting ", inetAddress, ' ', port, ' ', [((AndroidGovNistJavaxSipStackNioTcpMessageProcessor *) nil_chk(self->messageProcessor_)) getIpAddress])];
        [self removeSocketWithNSString:key];
        @throw create_JavaNetSocketException_initWithNSString_(JreStrcat("@C$C@$@CIC@", [((JavaNetSocketException *) nil_chk(e)) java_getClass], ' ', [e getMessage], ' ', [e getCause], @" Problem connecting ", inetAddress, ' ', port, ' ', [((AndroidGovNistJavaxSipStackNioTcpMessageProcessor *) nil_chk(self->messageProcessor_)) getIpAddress]));
      }
    }
    return channel;
  }
  @finally {
    [((AndroidGovNistJavaxSipStackKeyedSemaphore *) nil_chk(keyedSemaphore_)) leaveIOCriticalSectionWithNSString:key];
    [((id<OrgSlf4jLogger>) nil_chk(AndroidGovNistJavaxSipStackNIOHandler_logger)) debugWithNSString:JreStrcat("$$$@", @"Returning socket ", key, @" channel = ", channel)];
  }
}

- (void)dealloc {
  RELEASE_(sipStack_);
  RELEASE_(messageProcessor_);
  RELEASE_(stopped_);
  RELEASE_(socketTable_);
  RELEASE_(keyedSemaphore_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, "LNSString;", 0xc, 0, 1, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0xc, 0, 2, -1, -1, -1, -1 },
    { NULL, NULL, 0x4, -1, 3, -1, -1, -1, -1 },
    { NULL, "V", 0x4, 4, 5, -1, -1, -1, -1 },
    { NULL, "LJavaNioChannelsSocketChannel;", 0x4, 6, 7, -1, -1, -1, -1 },
    { NULL, "V", 0x4, 8, 7, -1, -1, -1, -1 },
    { NULL, "V", 0x4, 8, 9, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 10, 11, -1, -1, -1, -1 },
    { NULL, "LJavaNioChannelsSocketChannel;", 0x1, 12, 13, 14, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LJavaNioChannelsSocketChannel;", 0x1, 15, 1, 14, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(makeKeyWithJavaNetInetAddress:withInt:);
  methods[1].selector = @selector(makeKeyWithNSString:withInt:);
  methods[2].selector = @selector(initWithAndroidGovNistJavaxSipStackSIPTransactionStack:withAndroidGovNistJavaxSipStackNioTcpMessageProcessor:);
  methods[3].selector = @selector(putSocketWithNSString:withJavaNioChannelsSocketChannel:);
  methods[4].selector = @selector(getSocketWithNSString:);
  methods[5].selector = @selector(removeSocketWithNSString:);
  methods[6].selector = @selector(removeSocketWithJavaNioChannelsSocketChannel:);
  methods[7].selector = @selector(writeChunksWithJavaNioChannelsSocketChannel:withByteArray:withInt:);
  methods[8].selector = @selector(sendBytesWithJavaNetInetAddress:withJavaNetInetAddress:withInt:withNSString:withByteArray:withBoolean:withAndroidGovNistJavaxSipStackNioTcpMessageChannel:);
  methods[9].selector = @selector(closeAll);
  methods[10].selector = @selector(stop);
  methods[11].selector = @selector(createOrReuseSocketWithJavaNetInetAddress:withInt:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "logger", "LOrgSlf4jLogger;", .constantValue.asLong = 0, 0xa, -1, 16, -1, -1 },
    { "sipStack_", "LAndroidGovNistJavaxSipSipStackImpl;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "messageProcessor_", "LAndroidGovNistJavaxSipStackNioTcpMessageProcessor;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "stopped_", "LJavaUtilConcurrentAtomicAtomicBoolean;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "socketTable_", "LJavaUtilConcurrentConcurrentHashMap;", .constantValue.asLong = 0, 0x12, -1, -1, 17, -1 },
    { "keyedSemaphore_", "LAndroidGovNistJavaxSipStackKeyedSemaphore;", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "makeKey", "LJavaNetInetAddress;I", "LNSString;I", "LAndroidGovNistJavaxSipStackSIPTransactionStack;LAndroidGovNistJavaxSipStackNioTcpMessageProcessor;", "putSocket", "LNSString;LJavaNioChannelsSocketChannel;", "getSocket", "LNSString;", "removeSocket", "LJavaNioChannelsSocketChannel;", "writeChunks", "LJavaNioChannelsSocketChannel;[BI", "sendBytes", "LJavaNetInetAddress;LJavaNetInetAddress;ILNSString;[BZLAndroidGovNistJavaxSipStackNioTcpMessageChannel;", "LJavaIoIOException;", "createOrReuseSocket", &AndroidGovNistJavaxSipStackNIOHandler_logger, "Ljava/util/concurrent/ConcurrentHashMap<Ljava/lang/String;Ljava/nio/channels/SocketChannel;>;" };
  static const J2ObjcClassInfo _AndroidGovNistJavaxSipStackNIOHandler = { "NIOHandler", "android.gov.nist.javax.sip.stack", ptrTable, methods, fields, 7, 0x1, 12, 6, -1, -1, -1, -1, -1 };
  return &_AndroidGovNistJavaxSipStackNIOHandler;
}

+ (void)initialize {
  if (self == [AndroidGovNistJavaxSipStackNIOHandler class]) {
    JreStrongAssign(&AndroidGovNistJavaxSipStackNIOHandler_logger, OrgSlf4jLoggerFactory_getLoggerWithIOSClass_(AndroidGovNistJavaxSipStackNIOHandler_class_()));
    J2OBJC_SET_INITIALIZED(AndroidGovNistJavaxSipStackNIOHandler)
  }
}

@end

NSString *AndroidGovNistJavaxSipStackNIOHandler_makeKeyWithJavaNetInetAddress_withInt_(JavaNetInetAddress *addr, jint port) {
  AndroidGovNistJavaxSipStackNIOHandler_initialize();
  return JreStrcat("$CI", [((JavaNetInetAddress *) nil_chk(addr)) getHostAddress], ':', port);
}

NSString *AndroidGovNistJavaxSipStackNIOHandler_makeKeyWithNSString_withInt_(NSString *addr, jint port) {
  AndroidGovNistJavaxSipStackNIOHandler_initialize();
  return JreStrcat("$CI", addr, ':', port);
}

void AndroidGovNistJavaxSipStackNIOHandler_initWithAndroidGovNistJavaxSipStackSIPTransactionStack_withAndroidGovNistJavaxSipStackNioTcpMessageProcessor_(AndroidGovNistJavaxSipStackNIOHandler *self, AndroidGovNistJavaxSipStackSIPTransactionStack *sipStack, AndroidGovNistJavaxSipStackNioTcpMessageProcessor *messageProcessor) {
  NSObject_init(self);
  JreStrongAssignAndConsume(&self->stopped_, new_JavaUtilConcurrentAtomicAtomicBoolean_initWithBoolean_(false));
  JreStrongAssignAndConsume(&self->socketTable_, new_JavaUtilConcurrentConcurrentHashMap_init());
  JreStrongAssignAndConsume(&self->keyedSemaphore_, new_AndroidGovNistJavaxSipStackKeyedSemaphore_init());
  JreStrongAssign(&self->sipStack_, (AndroidGovNistJavaxSipSipStackImpl *) cast_chk(sipStack, [AndroidGovNistJavaxSipSipStackImpl class]));
  JreStrongAssign(&self->messageProcessor_, messageProcessor);
}

AndroidGovNistJavaxSipStackNIOHandler *new_AndroidGovNistJavaxSipStackNIOHandler_initWithAndroidGovNistJavaxSipStackSIPTransactionStack_withAndroidGovNistJavaxSipStackNioTcpMessageProcessor_(AndroidGovNistJavaxSipStackSIPTransactionStack *sipStack, AndroidGovNistJavaxSipStackNioTcpMessageProcessor *messageProcessor) {
  J2OBJC_NEW_IMPL(AndroidGovNistJavaxSipStackNIOHandler, initWithAndroidGovNistJavaxSipStackSIPTransactionStack_withAndroidGovNistJavaxSipStackNioTcpMessageProcessor_, sipStack, messageProcessor)
}

AndroidGovNistJavaxSipStackNIOHandler *create_AndroidGovNistJavaxSipStackNIOHandler_initWithAndroidGovNistJavaxSipStackSIPTransactionStack_withAndroidGovNistJavaxSipStackNioTcpMessageProcessor_(AndroidGovNistJavaxSipStackSIPTransactionStack *sipStack, AndroidGovNistJavaxSipStackNioTcpMessageProcessor *messageProcessor) {
  J2OBJC_CREATE_IMPL(AndroidGovNistJavaxSipStackNIOHandler, initWithAndroidGovNistJavaxSipStackSIPTransactionStack_withAndroidGovNistJavaxSipStackNioTcpMessageProcessor_, sipStack, messageProcessor)
}

void AndroidGovNistJavaxSipStackNIOHandler_writeChunksWithJavaNioChannelsSocketChannel_withByteArray_withInt_(AndroidGovNistJavaxSipStackNIOHandler *self, JavaNioChannelsSocketChannel *channel, IOSByteArray *bytes, jint length) {
  @synchronized(channel) {
    IOSByteArray *buff = [IOSByteArray arrayWithLength:length];
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(bytes, 0, buff, 0, length);
    [((AndroidGovNistJavaxSipStackNioTcpMessageProcessor *) nil_chk(self->messageProcessor_)) sendWithJavaNioChannelsSocketChannel:channel withByteArray:bytes];
  }
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(AndroidGovNistJavaxSipStackNIOHandler)
