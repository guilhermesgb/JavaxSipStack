//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: ./src/android/gov/nist/javax/sip/stack/TLSMessageChannel.java
//

#include "IOSClass.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "android/gov/nist/javax/sip/header/CSeq.h"
#include "android/gov/nist/javax/sip/header/CallID.h"
#include "android/gov/nist/javax/sip/header/ContentLength.h"
#include "android/gov/nist/javax/sip/header/From.h"
#include "android/gov/nist/javax/sip/header/RequestLine.h"
#include "android/gov/nist/javax/sip/header/StatusLine.h"
#include "android/gov/nist/javax/sip/header/To.h"
#include "android/gov/nist/javax/sip/header/Via.h"
#include "android/gov/nist/javax/sip/message/SIPMessage.h"
#include "android/gov/nist/javax/sip/parser/PipelinedMsgParser.h"
#include "android/gov/nist/javax/sip/stack/ClientAuthType.h"
#include "android/gov/nist/javax/sip/stack/ConnectionOrientedMessageChannel.h"
#include "android/gov/nist/javax/sip/stack/HandshakeCompletedListenerImpl.h"
#include "android/gov/nist/javax/sip/stack/IOHandler.h"
#include "android/gov/nist/javax/sip/stack/MessageChannel.h"
#include "android/gov/nist/javax/sip/stack/MessageProcessor.h"
#include "android/gov/nist/javax/sip/stack/SIPTransactionStack.h"
#include "android/gov/nist/javax/sip/stack/TLSMessageChannel.h"
#include "android/gov/nist/javax/sip/stack/TLSMessageProcessor.h"
#include "java/io/IOException.h"
#include "java/io/InputStream.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/Thread.h"
#include "java/net/InetAddress.h"
#include "java/net/Socket.h"
#include "java/net/SocketAddress.h"
#include "java/text/ParseException.h"
#include "javax/net/ssl/HandshakeCompletedListener.h"
#include "javax/net/ssl/SSLSession.h"
#include "javax/net/ssl/SSLSocket.h"
#include "org/slf4j/Logger.h"
#include "org/slf4j/LoggerFactory.h"

@interface AndroidGovNistJavaxSipStackTLSMessageChannel () {
 @public
  id<JavaxNetSslHandshakeCompletedListener> handshakeCompletedListener_;
  jboolean handshakeCompleted_;
}

@end

J2OBJC_FIELD_SETTER(AndroidGovNistJavaxSipStackTLSMessageChannel, handshakeCompletedListener_, id<JavaxNetSslHandshakeCompletedListener>)

inline id<OrgSlf4jLogger> AndroidGovNistJavaxSipStackTLSMessageChannel_get_logger();
inline id<OrgSlf4jLogger> AndroidGovNistJavaxSipStackTLSMessageChannel_set_logger(id<OrgSlf4jLogger> value);
static id<OrgSlf4jLogger> AndroidGovNistJavaxSipStackTLSMessageChannel_logger;
J2OBJC_STATIC_FIELD_OBJ(AndroidGovNistJavaxSipStackTLSMessageChannel, logger, id<OrgSlf4jLogger>)

J2OBJC_INITIALIZED_DEFN(AndroidGovNistJavaxSipStackTLSMessageChannel)

@implementation AndroidGovNistJavaxSipStackTLSMessageChannel

- (instancetype)initWithJavaNetSocket:(JavaNetSocket *)sock
withAndroidGovNistJavaxSipStackSIPTransactionStack:(AndroidGovNistJavaxSipStackSIPTransactionStack *)sipStack
withAndroidGovNistJavaxSipStackTLSMessageProcessor:(AndroidGovNistJavaxSipStackTLSMessageProcessor *)msgProcessor
                         withNSString:(NSString *)threadName {
  AndroidGovNistJavaxSipStackTLSMessageChannel_initWithJavaNetSocket_withAndroidGovNistJavaxSipStackSIPTransactionStack_withAndroidGovNistJavaxSipStackTLSMessageProcessor_withNSString_(self, sock, sipStack, msgProcessor, threadName);
  return self;
}

- (instancetype)initWithJavaNetInetAddress:(JavaNetInetAddress *)inetAddr
                                   withInt:(jint)port
withAndroidGovNistJavaxSipStackSIPTransactionStack:(AndroidGovNistJavaxSipStackSIPTransactionStack *)sipStack
withAndroidGovNistJavaxSipStackTLSMessageProcessor:(AndroidGovNistJavaxSipStackTLSMessageProcessor *)messageProcessor {
  AndroidGovNistJavaxSipStackTLSMessageChannel_initWithJavaNetInetAddress_withInt_withAndroidGovNistJavaxSipStackSIPTransactionStack_withAndroidGovNistJavaxSipStackTLSMessageProcessor_(self, inetAddr, port, sipStack, messageProcessor);
  return self;
}

- (void)closeWithBoolean:(jboolean)removeSocket
             withBoolean:(jboolean)stopKeepAliveTask {
  isRunning_ = false;
  if (mySock_ != nil) {
    [((id<OrgSlf4jLogger>) nil_chk(AndroidGovNistJavaxSipStackTLSMessageChannel_logger)) debugWithNSString:JreStrcat("$$", @"Closing socket ", key_)];
    @try {
      [((JavaNetSocket *) nil_chk(mySock_)) close];
    }
    @catch (JavaIoIOException *ex) {
      [((id<OrgSlf4jLogger>) nil_chk(AndroidGovNistJavaxSipStackTLSMessageChannel_logger)) debugWithNSString:JreStrcat("$@", @"Error closing socket ", ex)];
    }
  }
  if (myParser_ != nil) {
    [((id<OrgSlf4jLogger>) nil_chk(AndroidGovNistJavaxSipStackTLSMessageChannel_logger)) debugWithNSString:JreStrcat("$@", @"Closing my parser ", myParser_)];
    [((AndroidGovNistJavaxSipParserPipelinedMsgParser *) nil_chk(myParser_)) close];
  }
  if (removeSocket) {
    NSString *ioHandlerKey = [((NSString *) nil_chk(key_)) java_substring:4];
    [((id<OrgSlf4jLogger>) nil_chk(AndroidGovNistJavaxSipStackTLSMessageChannel_logger)) debugWithNSString:JreStrcat("$$", @"Closing TLS socket ", ioHandlerKey)];
    [((AndroidGovNistJavaxSipStackIOHandler *) nil_chk(((AndroidGovNistJavaxSipStackSIPTransactionStack *) nil_chk(sipStack_))->ioHandler_)) removeSocketWithNSString:ioHandlerKey];
    [((id<OrgSlf4jLogger>) nil_chk(AndroidGovNistJavaxSipStackTLSMessageChannel_logger)) debugWithNSString:JreStrcat("$$C@", @"Closing message Channel (key = ", key_, ')', self)];
  }
  else {
    NSString *ioHandlerKey = [((NSString *) nil_chk(key_)) java_substring:4];
    [((id<OrgSlf4jLogger>) nil_chk(AndroidGovNistJavaxSipStackTLSMessageChannel_logger)) debugWithNSString:JreStrcat("$$", @"not removing socket key from the cached map since it has already been updated by the iohandler.sendBytes ", ioHandlerKey)];
  }
  if (stopKeepAliveTask) {
    [self cancelPingKeepAliveTimeoutTaskIfStarted];
  }
}

- (NSString *)getTransport {
  return @"TLS";
}

- (void)sendMessageWithByteArray:(IOSByteArray *)msg
                     withBoolean:(jboolean)retry {
  @synchronized(self) {
    [((id<OrgSlf4jLogger>) nil_chk(AndroidGovNistJavaxSipStackTLSMessageChannel_logger)) debugWithNSString:JreStrcat("$Z", @"sendMessage isClient  = ", retry)];
    JavaNetSocket *sock = nil;
    JavaIoIOException *problem = nil;
    @try {
      sock = [((AndroidGovNistJavaxSipStackIOHandler *) nil_chk(((AndroidGovNistJavaxSipStackSIPTransactionStack *) nil_chk(self->sipStack_))->ioHandler_)) sendBytesWithJavaNetInetAddress:[((AndroidGovNistJavaxSipStackMessageProcessor *) nil_chk([self getMessageProcessor])) getIpAddress] withJavaNetInetAddress:self->peerAddress_ withInt:self->peerPort_ withNSString:self->peerProtocol_ withByteArray:msg withBoolean:retry withAndroidGovNistJavaxSipStackMessageChannel:self];
    }
    @catch (JavaIoIOException *any) {
      problem = any;
      [((id<OrgSlf4jLogger>) nil_chk(AndroidGovNistJavaxSipStackTLSMessageChannel_logger)) warnWithNSString:JreStrcat("$@CI$I$", @"Failed to connect ", self->peerAddress_, ':', self->peerPort_, @" but trying the advertised port=", self->peerPortAdvertisedInHeaders_, @" if it's different than the port we just failed on")];
      [((id<OrgSlf4jLogger>) nil_chk(AndroidGovNistJavaxSipStackTLSMessageChannel_logger)) errorWithNSString:@"Error is " withNSException:any];
    }
    if (sock == nil) {
      if (peerAddressAdvertisedInHeaders_ != nil && peerPortAdvertisedInHeaders_ > 0) {
        [((id<OrgSlf4jLogger>) nil_chk(AndroidGovNistJavaxSipStackTLSMessageChannel_logger)) warnWithNSString:JreStrcat("$@$I$$$I", @"Couldn't connect to peerAddress = ", peerAddress_, @" peerPort = ", peerPort_, @" key = ", key_, @" retrying on peerPortAdvertisedInHeaders ", peerPortAdvertisedInHeaders_)];
        JavaNetInetAddress *address = JavaNetInetAddress_getByNameWithNSString_(peerAddressAdvertisedInHeaders_);
        sock = [((AndroidGovNistJavaxSipStackIOHandler *) nil_chk(((AndroidGovNistJavaxSipStackSIPTransactionStack *) nil_chk(self->sipStack_))->ioHandler_)) sendBytesWithJavaNetInetAddress:[((AndroidGovNistJavaxSipStackMessageProcessor *) nil_chk(self->messageProcessor_)) getIpAddress] withJavaNetInetAddress:address withInt:self->peerPortAdvertisedInHeaders_ withNSString:self->peerProtocol_ withByteArray:msg withBoolean:retry withAndroidGovNistJavaxSipStackMessageChannel:self];
        self->peerPort_ = self->peerPortAdvertisedInHeaders_;
        JreStrongAssign(&self->peerAddress_, address);
        JreStrongAssign(&self->key_, AndroidGovNistJavaxSipStackMessageChannel_getKeyWithJavaNetInetAddress_withInt_withNSString_(peerAddress_, peerPort_, @"TLS"));
        [((id<OrgSlf4jLogger>) nil_chk(AndroidGovNistJavaxSipStackTLSMessageChannel_logger)) warnWithNSString:JreStrcat("$@$I$$", @"retry suceeded to peerAddress = ", peerAddress_, @" peerPortAdvertisedInHeaders = ", peerPortAdvertisedInHeaders_, @" key = ", key_)];
      }
      else {
        @throw problem;
      }
    }
    if (sock != mySock_ && sock != nil) {
      if (mySock_ != nil) {
        [((id<OrgSlf4jLogger>) nil_chk(AndroidGovNistJavaxSipStackTLSMessageChannel_logger)) warnWithNSString:JreStrcat("$$", @"Old socket different than new socket on channel ", key_)];
        [((id<OrgSlf4jLogger>) nil_chk(AndroidGovNistJavaxSipStackTLSMessageChannel_logger)) warnWithNSString:JreStrcat("$@", @"Old socket local ip address ", [((JavaNetSocket *) nil_chk(mySock_)) getLocalSocketAddress])];
        [((id<OrgSlf4jLogger>) nil_chk(AndroidGovNistJavaxSipStackTLSMessageChannel_logger)) warnWithNSString:JreStrcat("$@", @"Old socket remote ip address ", [((JavaNetSocket *) nil_chk(mySock_)) getRemoteSocketAddress])];
        [((id<OrgSlf4jLogger>) nil_chk(AndroidGovNistJavaxSipStackTLSMessageChannel_logger)) warnWithNSString:JreStrcat("$@", @"New socket local ip address ", [sock getLocalSocketAddress])];
        [((id<OrgSlf4jLogger>) nil_chk(AndroidGovNistJavaxSipStackTLSMessageChannel_logger)) warnWithNSString:JreStrcat("$@", @"New socket remote ip address ", [sock getRemoteSocketAddress])];
        [self closeWithBoolean:false withBoolean:false];
      }
      if (problem == nil) {
        if (mySock_ != nil) {
          [((id<OrgSlf4jLogger>) nil_chk(AndroidGovNistJavaxSipStackTLSMessageChannel_logger)) warnWithNSString:JreStrcat("$$", @"There was no exception for the retry mechanism so creating a new thread based on the new socket for incoming ", key_)];
        }
        JreStrongAssign(&mySock_, sock);
        JreStrongAssign(&self->myClientInputStream_, [mySock_ getInputStream]);
        JavaLangThread *thread = create_JavaLangThread_initWithJavaLangRunnable_(self);
        [thread setDaemonWithBoolean:true];
        [thread setNameWithNSString:@"TCPMessageChannelThread"];
        [thread start];
      }
      else {
        [((id<OrgSlf4jLogger>) nil_chk(AndroidGovNistJavaxSipStackTLSMessageChannel_logger)) warnWithNSString:JreStrcat("$$", @"There was an exception for the retry mechanism so not creating a new thread based on the new socket for incoming ", key_)];
        JreStrongAssign(&mySock_, sock);
      }
    }
  }
}

- (void)sendMessageWithByteArray:(IOSByteArray *)message
          withJavaNetInetAddress:(JavaNetInetAddress *)receiverAddress
                         withInt:(jint)receiverPort
                     withBoolean:(jboolean)retry {
  @synchronized(self) {
    if (message == nil || receiverAddress == nil) @throw create_JavaLangIllegalArgumentException_initWithNSString_(@"Null argument");
    if (peerPortAdvertisedInHeaders_ <= 0) {
      [((id<OrgSlf4jLogger>) nil_chk(AndroidGovNistJavaxSipStackTLSMessageChannel_logger)) debugWithNSString:JreStrcat("$I$@$$", @"receiver port = ", receiverPort, @" for this channel ", self, @" key ", key_)];
      if (receiverPort <= 0) {
        self->peerPortAdvertisedInHeaders_ = 5060;
      }
      else {
        self->peerPortAdvertisedInHeaders_ = receiverPort;
      }
      [((id<OrgSlf4jLogger>) nil_chk(AndroidGovNistJavaxSipStackTLSMessageChannel_logger)) debugWithNSString:JreStrcat("$I$@$$", @"2.Storing peerPortAdvertisedInHeaders = ", peerPortAdvertisedInHeaders_, @" for this channel ", self, @" key ", key_)];
    }
    JavaNetSocket *sock = nil;
    JavaIoIOException *problem = nil;
    @try {
      sock = [((AndroidGovNistJavaxSipStackIOHandler *) nil_chk(((AndroidGovNistJavaxSipStackSIPTransactionStack *) nil_chk(self->sipStack_))->ioHandler_)) sendBytesWithJavaNetInetAddress:[((AndroidGovNistJavaxSipStackMessageProcessor *) nil_chk(self->messageProcessor_)) getIpAddress] withJavaNetInetAddress:receiverAddress withInt:receiverPort withNSString:@"TLS" withByteArray:message withBoolean:retry withAndroidGovNistJavaxSipStackMessageChannel:self];
    }
    @catch (JavaIoIOException *any) {
      problem = any;
      [((id<OrgSlf4jLogger>) nil_chk(AndroidGovNistJavaxSipStackTLSMessageChannel_logger)) warnWithNSString:JreStrcat("$@CI$I$@$I", @"Failed to connect ", self->peerAddress_, ':', receiverPort, @" but trying the advertised port=", self->peerPortAdvertisedInHeaders_, @" if it's different than the port we just failed on, rcv addr=", receiverAddress, @", port=", receiverPort)];
      [((id<OrgSlf4jLogger>) nil_chk(AndroidGovNistJavaxSipStackTLSMessageChannel_logger)) errorWithNSString:@"Error is " withNSException:any];
    }
    if (sock == nil) {
      if (peerAddressAdvertisedInHeaders_ != nil && peerPortAdvertisedInHeaders_ > 0) {
        [((id<OrgSlf4jLogger>) nil_chk(AndroidGovNistJavaxSipStackTLSMessageChannel_logger)) warnWithNSString:JreStrcat("$@$I$$$I", @"Couldn't connect to receiverAddress = ", receiverAddress, @" receiverPort = ", receiverPort, @" key = ", key_, @" retrying on peerPortAdvertisedInHeaders ", peerPortAdvertisedInHeaders_)];
        JavaNetInetAddress *address = JavaNetInetAddress_getByNameWithNSString_(peerAddressAdvertisedInHeaders_);
        sock = [((AndroidGovNistJavaxSipStackIOHandler *) nil_chk(((AndroidGovNistJavaxSipStackSIPTransactionStack *) nil_chk(self->sipStack_))->ioHandler_)) sendBytesWithJavaNetInetAddress:[((AndroidGovNistJavaxSipStackMessageProcessor *) nil_chk(self->messageProcessor_)) getIpAddress] withJavaNetInetAddress:address withInt:self->peerPortAdvertisedInHeaders_ withNSString:@"TLS" withByteArray:message withBoolean:retry withAndroidGovNistJavaxSipStackMessageChannel:self];
        self->peerPort_ = self->peerPortAdvertisedInHeaders_;
        JreStrongAssign(&self->peerAddress_, address);
        JreStrongAssign(&self->key_, AndroidGovNistJavaxSipStackMessageChannel_getKeyWithJavaNetInetAddress_withInt_withNSString_(peerAddress_, peerPortAdvertisedInHeaders_, @"TLS"));
        [((id<OrgSlf4jLogger>) nil_chk(AndroidGovNistJavaxSipStackTLSMessageChannel_logger)) warnWithNSString:JreStrcat("$@$I$$", @"retry suceeded to receiverAddress = ", receiverAddress, @" peerPortAdvertisedInHeaders = ", peerPortAdvertisedInHeaders_, @" key = ", key_)];
      }
      else {
        @throw problem;
      }
    }
    if (sock != mySock_ && sock != nil) {
      if (mySock_ != nil) {
        [((id<OrgSlf4jLogger>) nil_chk(AndroidGovNistJavaxSipStackTLSMessageChannel_logger)) warnWithNSString:JreStrcat("$$", @"Old socket different than new socket on channel ", key_)];
        [((id<OrgSlf4jLogger>) nil_chk(AndroidGovNistJavaxSipStackTLSMessageChannel_logger)) warnWithNSString:JreStrcat("$@", @"Old socket local ip address ", [((JavaNetSocket *) nil_chk(mySock_)) getLocalSocketAddress])];
        [((id<OrgSlf4jLogger>) nil_chk(AndroidGovNistJavaxSipStackTLSMessageChannel_logger)) warnWithNSString:JreStrcat("$@", @"Old socket remote ip address ", [((JavaNetSocket *) nil_chk(mySock_)) getRemoteSocketAddress])];
        [((id<OrgSlf4jLogger>) nil_chk(AndroidGovNistJavaxSipStackTLSMessageChannel_logger)) warnWithNSString:JreStrcat("$@", @"New socket local ip address ", [sock getLocalSocketAddress])];
        [((id<OrgSlf4jLogger>) nil_chk(AndroidGovNistJavaxSipStackTLSMessageChannel_logger)) warnWithNSString:JreStrcat("$@", @"New socket remote ip address ", [sock getRemoteSocketAddress])];
        [self closeWithBoolean:false withBoolean:false];
      }
      if (problem == nil) {
        if (mySock_ != nil) {
          [((id<OrgSlf4jLogger>) nil_chk(AndroidGovNistJavaxSipStackTLSMessageChannel_logger)) warnWithNSString:JreStrcat("$$", @"There was no exception for the retry mechanism so creating a new thread based on the new socket for incoming ", key_)];
        }
        JreStrongAssign(&mySock_, sock);
        JreStrongAssign(&self->myClientInputStream_, [mySock_ getInputStream]);
        JavaLangThread *mythread = create_JavaLangThread_initWithJavaLangRunnable_(self);
        [mythread setDaemonWithBoolean:true];
        [mythread setNameWithNSString:@"TCPMessageChannelThread"];
        [mythread start];
      }
      else {
        [((id<OrgSlf4jLogger>) nil_chk(AndroidGovNistJavaxSipStackTLSMessageChannel_logger)) warnWithNSString:JreStrcat("$$", @"There was an exception for the retry mechanism so not creating a new thread based on the new socket for incoming ", key_)];
        JreStrongAssign(&mySock_, sock);
      }
    }
  }
}

- (void)handleExceptionWithJavaTextParseException:(JavaTextParseException *)ex
      withAndroidGovNistJavaxSipMessageSIPMessage:(AndroidGovNistJavaxSipMessageSIPMessage *)sipMessage
                                     withIOSClass:(IOSClass *)hdrClass
                                     withNSString:(NSString *)header
                                     withNSString:(NSString *)message {
  [((id<OrgSlf4jLogger>) nil_chk(AndroidGovNistJavaxSipStackTLSMessageChannel_logger)) errorWithNSString:@"ParseException" withNSException:ex];
  if ((hdrClass != nil) && ([((IOSClass *) nil_chk(hdrClass)) isEqual:AndroidGovNistJavaxSipHeaderFrom_class_()] || [hdrClass isEqual:AndroidGovNistJavaxSipHeaderTo_class_()] || [hdrClass isEqual:AndroidGovNistJavaxSipHeaderCSeq_class_()] || [hdrClass isEqual:AndroidGovNistJavaxSipHeaderVia_class_()] || [hdrClass isEqual:AndroidGovNistJavaxSipHeaderCallID_class_()] || [hdrClass isEqual:AndroidGovNistJavaxSipHeaderContentLength_class_()] || [hdrClass isEqual:AndroidGovNistJavaxSipHeaderRequestLine_class_()] || [hdrClass isEqual:AndroidGovNistJavaxSipHeaderStatusLine_class_()])) {
    [((id<OrgSlf4jLogger>) nil_chk(AndroidGovNistJavaxSipStackTLSMessageChannel_logger)) debugWithNSString:JreStrcat("$$", @"Encountered bad message \n", message)];
    NSString *msgString = [((AndroidGovNistJavaxSipMessageSIPMessage *) nil_chk(sipMessage)) description];
    if (![((NSString *) nil_chk(msgString)) hasPrefix:@"SIP/"] && ![msgString hasPrefix:@"ACK "]) {
      NSString *badReqRes = [self createBadReqResWithNSString:msgString withJavaTextParseException:ex];
      if (badReqRes != nil) {
        [((id<OrgSlf4jLogger>) nil_chk(AndroidGovNistJavaxSipStackTLSMessageChannel_logger)) debugWithNSString:@"Sending automatic 400 Bad Request:"];
        [((id<OrgSlf4jLogger>) nil_chk(AndroidGovNistJavaxSipStackTLSMessageChannel_logger)) debugWithNSString:badReqRes];
        @try {
          [self sendMessageWithByteArray:[badReqRes java_getBytes] withJavaNetInetAddress:[self getPeerInetAddress] withInt:[self getPeerPort] withBoolean:false];
        }
        @catch (JavaIoIOException *e) {
          [((id<OrgSlf4jLogger>) nil_chk(AndroidGovNistJavaxSipStackTLSMessageChannel_logger)) errorWithNSString:@"IOException" withNSException:e];
        }
      }
      else {
        [((id<OrgSlf4jLogger>) nil_chk(AndroidGovNistJavaxSipStackTLSMessageChannel_logger)) debugWithNSString:@"Could not formulate automatic 400 Bad Request"];
      }
    }
    @throw ex;
  }
  else {
    [((AndroidGovNistJavaxSipMessageSIPMessage *) nil_chk(sipMessage)) addUnparsedWithNSString:header];
  }
}

- (jboolean)isEqual:(id)other {
  if (![[self java_getClass] isEqual:[nil_chk(other) java_getClass]]) return false;
  else {
    AndroidGovNistJavaxSipStackTLSMessageChannel *that = (AndroidGovNistJavaxSipStackTLSMessageChannel *) cast_chk(other, [AndroidGovNistJavaxSipStackTLSMessageChannel class]);
    if (self->mySock_ != that->mySock_) return false;
    else return true;
  }
}

- (jboolean)isSecure {
  return true;
}

- (void)setHandshakeCompletedListenerWithJavaxNetSslHandshakeCompletedListener:(id<JavaxNetSslHandshakeCompletedListener>)handshakeCompletedListenerImpl {
  JreStrongAssign(&self->handshakeCompletedListener_, handshakeCompletedListenerImpl);
}

- (AndroidGovNistJavaxSipStackHandshakeCompletedListenerImpl *)getHandshakeCompletedListener {
  return (AndroidGovNistJavaxSipStackHandshakeCompletedListenerImpl *) cast_chk(handshakeCompletedListener_, [AndroidGovNistJavaxSipStackHandshakeCompletedListenerImpl class]);
}

- (void)run {
  if (mySock_ != nil && [mySock_ isKindOfClass:[JavaxNetSslSSLSocket class]] && !handshakeCompleted_) {
    JavaxNetSslSSLSocket *sslSock = (JavaxNetSslSSLSocket *) cast_chk(mySock_, [JavaxNetSslSSLSocket class]);
    AndroidGovNistJavaxSipStackHandshakeCompletedListenerImpl *listener = create_AndroidGovNistJavaxSipStackHandshakeCompletedListenerImpl_initWithAndroidGovNistJavaxSipStackTLSMessageChannel_withJavaNetSocket_(self, sslSock);
    JreStrongAssign(&self->handshakeCompletedListener_, listener);
    [sslSock addHandshakeCompletedListenerWithJavaxNetSslHandshakeCompletedListener:self->handshakeCompletedListener_];
    [listener startHandshakeWatchdog];
    @try {
      [sslSock startHandshake];
      handshakeCompleted_ = true;
      if (![((AndroidGovNistJavaxSipStackSIPTransactionStack *) nil_chk([self getSIPStack])) isSslRenegotiationEnabled]) {
        [((id<JavaxNetSslSSLSession>) nil_chk([sslSock getSession])) invalidate];
        [sslSock setEnableSessionCreationWithBoolean:false];
      }
    }
    @catch (JavaIoIOException *e) {
      [((id<OrgSlf4jLogger>) nil_chk(AndroidGovNistJavaxSipStackTLSMessageChannel_logger)) errorWithNSString:@"A problem occured while Accepting connection" withNSException:e];
      [sslSock removeHandshakeCompletedListenerWithJavaxNetSslHandshakeCompletedListener:handshakeCompletedListener_];
      JreStrongAssign(&handshakeCompletedListener_, nil);
      @try {
        [((JavaIoInputStream *) nil_chk(myClientInputStream_)) close];
      }
      @catch (JavaIoIOException *e1) {
      }
      @finally {
        JreStrongAssign(&myClientInputStream_, nil);
      }
      @try {
        [((JavaNetSocket *) nil_chk(mySock_)) close];
      }
      @catch (JavaIoIOException *e1) {
      }
      @finally {
        JreStrongAssign(&mySock_, nil);
      }
      return;
    }
  }
  [super run];
}

- (jboolean)isHandshakeCompleted {
  return handshakeCompleted_;
}

- (void)setHandshakeCompletedWithBoolean:(jboolean)handshakeCompleted {
  self->handshakeCompleted_ = handshakeCompleted;
}

- (void)dealloc {
  RELEASE_(handshakeCompletedListener_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x4, -1, 0, 1, -1, -1, -1 },
    { NULL, NULL, 0x4, -1, 2, 1, -1, -1, -1 },
    { NULL, "V", 0x1, 3, 4, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x24, 5, 6, 1, -1, -1, -1 },
    { NULL, "V", 0x21, 5, 7, 1, -1, -1, -1 },
    { NULL, "V", 0x1, 8, 9, 10, -1, -1, -1 },
    { NULL, "Z", 0x1, 11, 12, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 13, 14, -1, -1, -1, -1 },
    { NULL, "LAndroidGovNistJavaxSipStackHandshakeCompletedListenerImpl;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 15, 16, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(initWithJavaNetSocket:withAndroidGovNistJavaxSipStackSIPTransactionStack:withAndroidGovNistJavaxSipStackTLSMessageProcessor:withNSString:);
  methods[1].selector = @selector(initWithJavaNetInetAddress:withInt:withAndroidGovNistJavaxSipStackSIPTransactionStack:withAndroidGovNistJavaxSipStackTLSMessageProcessor:);
  methods[2].selector = @selector(closeWithBoolean:withBoolean:);
  methods[3].selector = @selector(getTransport);
  methods[4].selector = @selector(sendMessageWithByteArray:withBoolean:);
  methods[5].selector = @selector(sendMessageWithByteArray:withJavaNetInetAddress:withInt:withBoolean:);
  methods[6].selector = @selector(handleExceptionWithJavaTextParseException:withAndroidGovNistJavaxSipMessageSIPMessage:withIOSClass:withNSString:withNSString:);
  methods[7].selector = @selector(isEqual:);
  methods[8].selector = @selector(isSecure);
  methods[9].selector = @selector(setHandshakeCompletedListenerWithJavaxNetSslHandshakeCompletedListener:);
  methods[10].selector = @selector(getHandshakeCompletedListener);
  methods[11].selector = @selector(run);
  methods[12].selector = @selector(isHandshakeCompleted);
  methods[13].selector = @selector(setHandshakeCompletedWithBoolean:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "logger", "LOrgSlf4jLogger;", .constantValue.asLong = 0, 0xa, -1, 17, -1, -1 },
    { "handshakeCompletedListener_", "LJavaxNetSslHandshakeCompletedListener;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "handshakeCompleted_", "Z", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LJavaNetSocket;LAndroidGovNistJavaxSipStackSIPTransactionStack;LAndroidGovNistJavaxSipStackTLSMessageProcessor;LNSString;", "LJavaIoIOException;", "LJavaNetInetAddress;ILAndroidGovNistJavaxSipStackSIPTransactionStack;LAndroidGovNistJavaxSipStackTLSMessageProcessor;", "close", "ZZ", "sendMessage", "[BZ", "[BLJavaNetInetAddress;IZ", "handleException", "LJavaTextParseException;LAndroidGovNistJavaxSipMessageSIPMessage;LIOSClass;LNSString;LNSString;", "LJavaTextParseException;", "equals", "LNSObject;", "setHandshakeCompletedListener", "LJavaxNetSslHandshakeCompletedListener;", "setHandshakeCompleted", "Z", &AndroidGovNistJavaxSipStackTLSMessageChannel_logger };
  static const J2ObjcClassInfo _AndroidGovNistJavaxSipStackTLSMessageChannel = { "TLSMessageChannel", "android.gov.nist.javax.sip.stack", ptrTable, methods, fields, 7, 0x1, 14, 3, -1, -1, -1, -1, -1 };
  return &_AndroidGovNistJavaxSipStackTLSMessageChannel;
}

+ (void)initialize {
  if (self == [AndroidGovNistJavaxSipStackTLSMessageChannel class]) {
    JreStrongAssign(&AndroidGovNistJavaxSipStackTLSMessageChannel_logger, OrgSlf4jLoggerFactory_getLoggerWithIOSClass_(AndroidGovNistJavaxSipStackTLSMessageChannel_class_()));
    J2OBJC_SET_INITIALIZED(AndroidGovNistJavaxSipStackTLSMessageChannel)
  }
}

@end

void AndroidGovNistJavaxSipStackTLSMessageChannel_initWithJavaNetSocket_withAndroidGovNistJavaxSipStackSIPTransactionStack_withAndroidGovNistJavaxSipStackTLSMessageProcessor_withNSString_(AndroidGovNistJavaxSipStackTLSMessageChannel *self, JavaNetSocket *sock, AndroidGovNistJavaxSipStackSIPTransactionStack *sipStack, AndroidGovNistJavaxSipStackTLSMessageProcessor *msgProcessor, NSString *threadName) {
  AndroidGovNistJavaxSipStackConnectionOrientedMessageChannel_initWithAndroidGovNistJavaxSipStackSIPTransactionStack_(self, sipStack);
  self->handshakeCompleted_ = false;
  [((id<OrgSlf4jLogger>) nil_chk(AndroidGovNistJavaxSipStackTLSMessageChannel_logger)) debugWithNSString:@"creating new TLSMessageChannel (incoming)"];
  JreStrongAssign(&self->mySock_, (JavaxNetSslSSLSocket *) cast_chk(sock, [JavaxNetSslSSLSocket class]));
  if ([sock isKindOfClass:[JavaxNetSslSSLSocket class]]) {
    JavaxNetSslSSLSocket *sslSock = (JavaxNetSslSSLSocket *) cast_chk(sock, [JavaxNetSslSSLSocket class]);
    if ([((AndroidGovNistJavaxSipStackSIPTransactionStack *) nil_chk(sipStack)) getClientAuth] != JreLoadEnum(AndroidGovNistJavaxSipStackClientAuthType, Want) && [sipStack getClientAuth] != JreLoadEnum(AndroidGovNistJavaxSipStackClientAuthType, Disabled) && [sipStack getClientAuth] != JreLoadEnum(AndroidGovNistJavaxSipStackClientAuthType, DisabledAll)) {
      [((JavaxNetSslSSLSocket *) nil_chk(sslSock)) setNeedClientAuthWithBoolean:true];
    }
    [((id<OrgSlf4jLogger>) nil_chk(AndroidGovNistJavaxSipStackTLSMessageChannel_logger)) debugWithNSString:JreStrcat("$Z", @"SSLServerSocket need client auth ", [((JavaxNetSslSSLSocket *) nil_chk(sslSock)) getNeedClientAuth])];
  }
  JreStrongAssign(&self->peerAddress_, [((JavaNetSocket *) nil_chk(self->mySock_)) getInetAddress]);
  JreStrongAssign(&self->myAddress_, [((JavaNetInetAddress *) nil_chk([((AndroidGovNistJavaxSipStackTLSMessageProcessor *) nil_chk(msgProcessor)) getIpAddress])) getHostAddress]);
  JreStrongAssign(&self->myClientInputStream_, [((JavaNetSocket *) nil_chk(self->mySock_)) getInputStream]);
  JreStrongAssignAndConsume(&self->mythread_, new_JavaLangThread_initWithJavaLangRunnable_(self));
  [self->mythread_ setDaemonWithBoolean:true];
  [((JavaLangThread *) nil_chk(self->mythread_)) setNameWithNSString:threadName];
  self->myPort_ = [msgProcessor getPort];
  self->peerPort_ = [((JavaNetSocket *) nil_chk(self->mySock_)) getPort];
  JreStrongAssign(&self->key_, AndroidGovNistJavaxSipStackMessageChannel_getKeyWithJavaNetInetAddress_withInt_withNSString_(self->peerAddress_, self->peerPort_, @"TLS"));
  JreStrongAssign(&self->messageProcessor_, msgProcessor);
  [((JavaLangThread *) nil_chk(self->mythread_)) start];
}

AndroidGovNistJavaxSipStackTLSMessageChannel *new_AndroidGovNistJavaxSipStackTLSMessageChannel_initWithJavaNetSocket_withAndroidGovNistJavaxSipStackSIPTransactionStack_withAndroidGovNistJavaxSipStackTLSMessageProcessor_withNSString_(JavaNetSocket *sock, AndroidGovNistJavaxSipStackSIPTransactionStack *sipStack, AndroidGovNistJavaxSipStackTLSMessageProcessor *msgProcessor, NSString *threadName) {
  J2OBJC_NEW_IMPL(AndroidGovNistJavaxSipStackTLSMessageChannel, initWithJavaNetSocket_withAndroidGovNistJavaxSipStackSIPTransactionStack_withAndroidGovNistJavaxSipStackTLSMessageProcessor_withNSString_, sock, sipStack, msgProcessor, threadName)
}

AndroidGovNistJavaxSipStackTLSMessageChannel *create_AndroidGovNistJavaxSipStackTLSMessageChannel_initWithJavaNetSocket_withAndroidGovNistJavaxSipStackSIPTransactionStack_withAndroidGovNistJavaxSipStackTLSMessageProcessor_withNSString_(JavaNetSocket *sock, AndroidGovNistJavaxSipStackSIPTransactionStack *sipStack, AndroidGovNistJavaxSipStackTLSMessageProcessor *msgProcessor, NSString *threadName) {
  J2OBJC_CREATE_IMPL(AndroidGovNistJavaxSipStackTLSMessageChannel, initWithJavaNetSocket_withAndroidGovNistJavaxSipStackSIPTransactionStack_withAndroidGovNistJavaxSipStackTLSMessageProcessor_withNSString_, sock, sipStack, msgProcessor, threadName)
}

void AndroidGovNistJavaxSipStackTLSMessageChannel_initWithJavaNetInetAddress_withInt_withAndroidGovNistJavaxSipStackSIPTransactionStack_withAndroidGovNistJavaxSipStackTLSMessageProcessor_(AndroidGovNistJavaxSipStackTLSMessageChannel *self, JavaNetInetAddress *inetAddr, jint port, AndroidGovNistJavaxSipStackSIPTransactionStack *sipStack, AndroidGovNistJavaxSipStackTLSMessageProcessor *messageProcessor) {
  AndroidGovNistJavaxSipStackConnectionOrientedMessageChannel_initWithAndroidGovNistJavaxSipStackSIPTransactionStack_(self, sipStack);
  self->handshakeCompleted_ = false;
  [((id<OrgSlf4jLogger>) nil_chk(AndroidGovNistJavaxSipStackTLSMessageChannel_logger)) debugWithNSString:@"creating new TLSMessageChannel (outgoing)"];
  JreStrongAssign(&self->peerAddress_, inetAddr);
  self->peerPort_ = port;
  self->myPort_ = [((AndroidGovNistJavaxSipStackTLSMessageProcessor *) nil_chk(messageProcessor)) getPort];
  JreStrongAssign(&self->peerProtocol_, @"TLS");
  JreStrongAssign(&self->sipStack_, sipStack);
  JreStrongAssign(&self->myAddress_, [((JavaNetInetAddress *) nil_chk([messageProcessor getIpAddress])) getHostAddress]);
  JreStrongAssign(&self->key_, AndroidGovNistJavaxSipStackMessageChannel_getKeyWithJavaNetInetAddress_withInt_withNSString_(self->peerAddress_, self->peerPort_, @"TLS"));
  JreStrongAssign(&self->messageProcessor_, messageProcessor);
}

AndroidGovNistJavaxSipStackTLSMessageChannel *new_AndroidGovNistJavaxSipStackTLSMessageChannel_initWithJavaNetInetAddress_withInt_withAndroidGovNistJavaxSipStackSIPTransactionStack_withAndroidGovNistJavaxSipStackTLSMessageProcessor_(JavaNetInetAddress *inetAddr, jint port, AndroidGovNistJavaxSipStackSIPTransactionStack *sipStack, AndroidGovNistJavaxSipStackTLSMessageProcessor *messageProcessor) {
  J2OBJC_NEW_IMPL(AndroidGovNistJavaxSipStackTLSMessageChannel, initWithJavaNetInetAddress_withInt_withAndroidGovNistJavaxSipStackSIPTransactionStack_withAndroidGovNistJavaxSipStackTLSMessageProcessor_, inetAddr, port, sipStack, messageProcessor)
}

AndroidGovNistJavaxSipStackTLSMessageChannel *create_AndroidGovNistJavaxSipStackTLSMessageChannel_initWithJavaNetInetAddress_withInt_withAndroidGovNistJavaxSipStackSIPTransactionStack_withAndroidGovNistJavaxSipStackTLSMessageProcessor_(JavaNetInetAddress *inetAddr, jint port, AndroidGovNistJavaxSipStackSIPTransactionStack *sipStack, AndroidGovNistJavaxSipStackTLSMessageProcessor *messageProcessor) {
  J2OBJC_CREATE_IMPL(AndroidGovNistJavaxSipStackTLSMessageChannel, initWithJavaNetInetAddress_withInt_withAndroidGovNistJavaxSipStackSIPTransactionStack_withAndroidGovNistJavaxSipStackTLSMessageProcessor_, inetAddr, port, sipStack, messageProcessor)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(AndroidGovNistJavaxSipStackTLSMessageChannel)
